////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ

// Прокси-объект для взаимодействия с внешним миром, 
// когда браузер тестов открывается извне, например,
// скриптом для Снегопата.
// 
Перем mMiddleMan;

Перем мИнформатор; // работа с таблицей методов в runtime
Перем мПытаемсяСоздатьИнформатор;

Перем мЗначенияСостоянияТестов Экспорт;
Перем мЗначенияТиповСтроки Экспорт;
Перем мЗначениеМодульИлиФорма Экспорт;
Перем	ОшибкиСравненияТаблиц Экспорт;

// Хранит количество загруженных тестовых случаев.
Перем мКоличествоТестовыхСлучаев Экспорт;

Перем мСоответствиеСтатусовДляTeamCity;

Функция Версия() Экспорт
	Возврат "2.7.0.5";
КонецФункции

Функция ЗаголовокФормы() Экспорт
	Возврат СокрЛП(Метаданные().Синоним) + ", версия " + Версия();;
КонецФункции

//{ МЕТОДЫ ДЛЯ ПРОВЕРКИ ЗНАЧЕНИЙ (assertions). 

Процедура Проверить(_Истина, ДопСообщениеОшибки = "") Экспорт
	Если Не _Истина Тогда
		СообщениеОшибки = "Переданный параметр ("+Формат(_Истина, "БЛ=ложь; БИ=истина")+") не является Истиной, а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьИстину(_Истина, ДопСообщениеОшибки = "") Экспорт
	Проверить(_Истина, ДопСообщениеОшибки);
КонецПроцедуры

Процедура ПроверитьЛожь(_Ложь, ДопСообщениеОшибки = "") Экспорт
	Если _Ложь Тогда
		СообщениеОшибки = "Переданный параметр ("+Формат(_Ложь, "БЛ=ложь; БИ=истина")+") не является Ложью, а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьДату(_Дата, _Период, ДопСообщениеОшибки = "") Экспорт
	Если _Дата < _Период.ДатаНачала или _Дата > _Период.ДатаОкончания Тогда
		представление = ПредставлениеПериода(_Период.ДатаНачала, _Период.ДатаОкончания, "ФП = Истина");
		СообщениеОшибки = "Переданный параметр ("+Формат(_Дата, "ДФ='dd.MM.yyyy HH:mm:ss'")+") не входит в период "+представление+", а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьРавенствоДатСТочностью2Секунды(_Дата, _Дата2, ДопСообщениеОшибки = "") Экспорт
	Если _Дата < _Дата2-2 или _Дата > _Дата2+2 Тогда
		СообщениеОшибки = "Переданная дата ("+Формат(_Дата, "ДФ='dd.MM.yyyy HH:mm:ss'")+") не равна дате ("+Формат(_Дата2, "ДФ='dd.MM.yyyy HH:mm:ss'")+") с точностью до 2-х секунд, а хотели, чтобы они равнялись." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьРавенство(_1, _2, ДопСообщениеОшибки = "") Экспорт
	Если _1 <> _2 Тогда
		СообщениеОшибки = "Сравниваемые значения ("+_1+"; "+_2+") не равны, а хотели, чтобы были равны." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьНеРавенство(_1, _2, ДопСообщениеОшибки = "") Экспорт
	Если _1 = _2 Тогда
		СообщениеОшибки = "Сравниваемые значения ("+_1+"; "+_2+") равны, а хотели, чтобы были не равны." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьБольше(_Больше, _Меньше, ДопСообщениеОшибки = "") Экспорт
	Если _Больше <= _Меньше Тогда
		СообщениеОшибки = "Первый параметр ("+_Больше+") меньше или равен второму ("+_Меньше+") а хотели, чтобы был больше." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьБольшеИлиРавно(_Больше, _Меньше, ДопСообщениеОшибки = "") Экспорт
	Если _Больше < _Меньше Тогда
		СообщениеОшибки = "Первый параметр ("+_Больше+") меньше второго ("+_Меньше+") а хотели, чтобы был больше или равен." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМеньше(проверяемоеЗначение1, проверяемоеЗначение2, СообщениеОбОшибке = "") Экспорт
	Если проверяемоеЗначение1 >= проверяемоеЗначение2 Тогда
		ВызватьИсключение "Значение <"+проверяемоеЗначение1+"> больше или равно, чем <"+проверяемоеЗначение2+">, а ожидалось меньше"+
				ФорматДСО(СообщениеОбОшибке);
	КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьМеньшеИлиРавно(проверяемоеЗначение1, проверяемоеЗначение2, СообщениеОбОшибке = "") Экспорт
	Если проверяемоеЗначение1 > проверяемоеЗначение2 Тогда
		ВызватьИсключение "Значение <"+проверяемоеЗначение1+"> больше, чем <"+проверяемоеЗначение2+">, а ожидалось меньше или равно"+
				ФорматДСО(СообщениеОбОшибке);
	КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьВыполнилось(Знач СтрокаАлгоритм, ПараметрыИлиДопСообщениеОшибки = Неопределено, Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры;
	Если ТипЗнч(ПараметрыИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = ПараметрыИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиДопСообщениеОшибки;
	КонецЕсли;
	Попытка
		Выполнить(СтрокаАлгоритм);
		Упало = Ложь;
	Исключение
		Упало = Истина;
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если Упало Тогда
		СообщениеОшибки = "Хотели, чтобы алгоритм """+СтрокаАлгоритм+""" выполнился, а он упал с ошибкой """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМетодВыполнился(Объект, Знач ИмяМетода, ПараметрыИлиДопСообщениеОшибки = Неопределено, Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры;
	Если ТипЗнч(ПараметрыИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = ПараметрыИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиДопСообщениеОшибки;
	КонецЕсли;
	
	ПараметрыСтрока = ПараметрыСтрокой(Параметры);
	
	СтрокаВыполнения = "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
	Попытка
		Выполнить(СтрокаВыполнения);
		Упало = Ложь;
	Исключение
		Упало = Истина;
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если Упало Тогда
		СообщениеОшибки = "Хотели, чтобы код """+СтрокаВыполнения+""" выполнился, а он упал с ошибкой """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьНеВыполнилось(Знач СтрокаАлгоритм, ПараметрыИлиОжидаемоеОписаниеОшибки, Знач ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки = "", Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры, ОжидаемоеОписаниеОшибки; 
	Если ТипЗнч(ПараметрыИлиОжидаемоеОписаниеОшибки) = Тип("Строка") Тогда
		ОжидаемоеОписаниеОшибки = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ДопСообщениеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ОжидаемоеОписаниеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	КонецЕсли;
	Попытка
		Выполнить(СтрокаАлгоритм);
		Успех = Истина;
	Исключение
		Успех = Ложь;
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если Успех Тогда
		ВызватьИсключение("Хотели, чтобы алгоритм """+СтрокаАлгоритм+""" упал, а он выполнился" + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;
	Если Найти(ПолученноеОписаниеОшибки, ОжидаемоеОписаниеОшибки) = 0 Тогда
		ВызватьИсключение("Хотели, чтобы алгоритм """+СтрокаАлгоритм+""" упал с сообщением об ошибке """+ОжидаемоеОписаниеОшибки+""", а он упал с сообщением """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМетодНеВыполнился(Объект, ИмяМетода, ПараметрыИлиОжидаемоеОписаниеОшибки, Знач ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки = "", Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры, ОжидаемоеОписаниеОшибки; 
	Если ТипЗнч(ПараметрыИлиОжидаемоеОписаниеОшибки) = Тип("Строка") Тогда
		ОжидаемоеОписаниеОшибки = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ДопСообщениеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиОжидаемоеОписаниеОшибки;
		Если Параметры <> Неопределено Тогда
			ПроверитьТип(Параметры, "Массив", "Ожидали, что третьим параметром будет передан массив параметров для метода <"+ИмяМетода+">, а получили другой объект с типом <"+ТипЗнч(Параметры)+">");
		КонецЕсли;
		ОжидаемоеОписаниеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	КонецЕсли;
	
	ПараметрыСтрока = ПараметрыСтрокой(Параметры);
	
	СтрокаВыполнения = "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
	Попытка
		Выполнить(СтрокаВыполнения);
		Успех = Истина;
	Исключение
		Успех = Ложь;
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Если Успех Тогда
		ВызватьИсключение("Хотели, чтобы код """+СтрокаВыполнения+""" упал, а он выполнился" + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;
	Если Найти(ПолученноеОписаниеОшибки, ОжидаемоеОписаниеОшибки) = 0 Тогда
		ВызватьИсключение("Хотели, чтобы код """+СтрокаВыполнения+""" упал с сообщением об ошибке """+ОжидаемоеОписаниеОшибки+""", а он упал с сообщением """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;
КонецПроцедуры

Функция ПараметрыСтрокой(Параметры)
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	Возврат ПараметрыСтрока;
КонецФункции

// проверка идет через ЗначениеЗаполнено, но мутабельные значение всегда считаем заполненными
Процедура ПроверитьЗаполненность(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
    Попытка
        фЗаполнено = ЗначениеЗаполнено(ПроверяемоеЗначение);
    Исключение
        Возврат;
    КонецПопытки; 
    Если НЕ фЗаполнено Тогда
        ВызватьИсключение "Значение ("+ПроверяемоеЗначение+") не заполнено, а ожидалась заполненность" + ФорматДСО(ДопСообщениеОшибки);
    КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьНеЗаполненность(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	СообщениеОшибки = "Значение ("+ПроверяемоеЗначение+") заполнено, а ожидалась незаполненность" + ФорматДСО(ДопСообщениеОшибки);
	Попытка
        фЗаполнено = ЗначениеЗаполнено(ПроверяемоеЗначение);
    Исключение
        ВызватьИсключение СообщениеОшибки;
    КонецПопытки; 
    Если фЗаполнено Тогда
        ВызватьИсключение СообщениеОшибки;
    КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьТип(значение, ТипИлиИмяТипа, ДопСообщениеОшибки = "") Экспорт
    Если ТипЗнч(ТипИлиИмяТипа) = Тип("Строка") Тогда
        искомыйТип = Тип(ТипИлиИмяТипа);
    ИначеЕсли ТипЗнч(ТипИлиИмяТипа) = Тип("Тип") Тогда
        искомыйТип = ТипИлиИмяТипа;
    Иначе
        ВызватьИсключение "ПроверитьТип: Тип значения параметра ТипИлиИмяТипа должен быть <Тип> или <Строка>, а получили <"+ ТипЗнч(ТипИлиИмяТипа) + ">" + ФорматДСО(ДопСообщениеОшибки);
    КонецЕсли; 
    Если ТипЗнч(значение) <> искомыйТип Тогда
        ВызватьИсключение "Типом значения <"+значение+"> является <"+ТипЗнч(значение)+">, а ожидался тип <"+ТипИлиИмяТипа+">."+ФорматДСО(ДопСообщениеОшибки);
    КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьВхождение(строка, подстрокаПоиска, ДопСообщениеОшибки = "") Экспорт
	Если Найти(строка, подстрокаПоиска) = 0 Тогда
		СообщениеОшибки = "Искали в <"+строка+"> подстроку <"+подстрокаПоиска+">, но не нашли." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

//Коллекция - Массив, Структура, Соответствие, ФиксированныйМассив, ФиксированнаяСтруктура, ФиксированноеСоответствие, СписокЗначений
Процедура ПроверитьВхождениеВКоллекцию(Элемент, Коллекция, ДопСообщениеОшибки = "") Экспорт
	Нашли = Неопределено;
	ТипКоллекции = ТипЗнч(Коллекция);
	Если ТипКоллекции = Тип("Массив") или ТипКоллекции = Тип("ФиксированныйМассив") Тогда
		Нашли = Коллекция.Найти(Элемент) <> Неопределено;
	ИначеЕсли ТипКоллекции = Тип("Структура") или ТипКоллекции = Тип("Соответствие") 
			или ТипКоллекции = Тип("ФиксированнаяСтруктура") или ТипКоллекции = Тип("ФиксированноеСоответствие") Тогда
		Для каждого КлючЗначение Из Коллекция Цикл
			Нашли = КлючЗначение.Значение = Элемент;
			Если Нашли Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипКоллекции = Тип("СписокЗначений") Тогда
		Нашли = Коллекция.НайтиПоЗначению(Элемент) <> Неопределено;
	КонецЕсли;
	Если Нашли = Неопределено Тогда
		СообщениеОшибки = "Утверждение ""ПроверитьВхождениеВКоллекцию"" не умеет работать с типом коллекции <"+ТипКоллекции+">." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
	Если Не Нашли Тогда
		СообщениеОшибки = "Не нашли элемент <"+Элемент+"> в коллекции, а хотели, чтобы он был в коллекции." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьВалидностьЗапросаСКД(ТекстЗапроса, ДопСообщениеОшибки = "") Экспорт
	
	СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	
	ИсточникДанных 					  = СхемаКомпоновкиДанных.ИсточникиДанных.Добавить(); 
	ИсточникДанных.Имя                = "ИсточникДанных";
	ИсточникДанных.СтрокаСоединения   = "";
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных 							 = СхемаКомпоновкиДанных.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя            				 = "НаборДанных";
	НаборДанных.ИсточникДанных 				 = "ИсточникДанных";
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	НаборДанных.Запрос 						 = ТекстЗапроса;
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	Попытка
		КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	Исключение
		СообщениеОшибки = ОписаниеОшибки() + "." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);		
	КонецПопытки;
	
КонецПроцедуры // ПроверитьВалидностьЗапросаСКД()

Процедура ПроверитьНаличиеОбъектаИБ(ссылка, ДопСообщениеОшибки = "") Экспорт
	Если Не ЗначениеЗаполнено(ссылка) Тогда
		СообщениеОшибки = "Ожидали заполненность ссылки, а получили пустую ссылку." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
	лОбъект = ссылка.ПолучитьОбъект();
	Если лОбъект = Неопределено Тогда
		СообщениеОшибки = "Ожидали существование объекта в ИБ, а получили объект не найден <" + ссылка + "> ." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

// Проеряет равенство файлов
// Параметры:
//  ПутьФайла1, ПутьФайла2 - полные пути к фалйам
//  ПарамСравнениеФайлов - структура с ключами:
//                ИгнорироватьПустоеПространство
//                СпособСравнения
//                УчитыватьРазделителиСтрок
//                УчитыватьРегистр
//  ПоказатьРазличия - в случае ошибки появляется окно сравнеия (для отладки)
Процедура ПроверитьРавенствоФайлов(ПутьФайла1, ПутьФайла2, ДопСообщениеОшибки = "", ПарамСравнениеФайлов = Неопределено, ПоказатьРазличия = Ложь) Экспорт
#Если ТолстыйКлиентОбычноеПриложение или ТолстыйКлиентУправляемоеПриложение Тогда
	Если ПарамСравнениеФайлов = Неопределено Тогда
		ПарамСравнениеФайлов = Новый Структура;
	КонецЕсли;
	СравнениеФайлов = Новый СравнениеФайлов;
	СравнениеФайлов.ПервыйФайл = ПутьФайла1;
	СравнениеФайлов.ВторойФайл = ПутьФайла2;
	Если Не ПарамСравнениеФайлов.Свойство("СпособСравнения") Тогда
		Файл = Новый Файл(ПутьФайла1);
		ТипФайла = НРег(Файл.Расширение);
		ТекстовыеТипы = ".txt,.xml";
		Если ТипФайла = ".mxl" Тогда
			ПарамСравнениеФайлов.Вставить("СпособСравнения", СпособСравненияФайлов.ТабличныйДокумент);
		ИначеЕсли Найти(ТекстовыеТипы, ТипФайла) > 0 Тогда
			ПарамСравнениеФайлов.Вставить("СпособСравнения", СпособСравненияФайлов.ТекстовыйДокумент);
		КонецЕсли;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(СравнениеФайлов, ПарамСравнениеФайлов);
	ФайлыИдентичны = СравнениеФайлов.Сравнить();
	Если Не ФайлыИдентичны Тогда
		Если ПоказатьРазличия Тогда // для удобства отладки и расследования ошибок
			СравнениеФайлов.ПоказатьРазличия();
		КонецЕсли;
		СообщениеОшибки = "Ожидали идентичность файлов, а получили, что они различны." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
#Иначе 
	ВызватьИсключение "Утверждение ПроверитьРавенствоФайлов можно использовать только в толстом клиенте!";
#КонецЕсли
КонецПроцедуры


Процедура ПроверитьРавенствоТаблиц(Таб1, Таб2, ДопСообщениеОшибки = "") Экспорт
	#Если ТолстыйКлиентОбычноеПриложение или ТолстыйКлиентУправляемоеПриложение ИЛИ Сервер или ВнешнееСоединение Тогда
		
		ПроверитьТип(Таб1, "ТаблицаЗначений", "ПроверитьРавенствоТаблиц: Первый параметр-таблица таблицей не является");
		ПроверитьТип(Таб2, "ТаблицаЗначений", "ПроверитьРавенствоТаблиц: Второй параметр-таблица таблицей не является");
		
		ТабРазличий = Новый ТаблицаЗначений;
		ФлагСравнения = Различны(Таб1, Таб2, ТабРазличий);    
		
		Если ОшибкиСравненияТаблиц.ВидОшибки_НетОшибок <> ФлагСравнения Тогда
			 		
			СоответствиеПоиска = Новый Соответствие;
			Для каждого КлючЗначение Из ОшибкиСравненияТаблиц Цикл
				СоответствиеПоиска.Вставить(КлючЗначение.Значение, КлючЗначение.Ключ);
			КонецЦикла; 
			СтрокаОшибок = "Различия в таблицах:"+Символы.ПС;
			СтрокаОшибок = СтрокаОшибок + "Ожидали статус <"+ СоответствиеПоиска[ОшибкиСравненияТаблиц.ВидОшибки_НетОшибок]+">, а получили <"+СоответствиеПоиска[ФлагСравнения]+">"+Символы.ПС;
			Для каждого Строка Из ТабРазличий Цикл
				СтрокаОшибок = СтрокаОшибок + "Значение ["+Строка.Колонка+":"+Строка.Строка+"]. Ожидали <"+Строка.Ожидание+">, а получили <"+Строка.Результат+">"+Символы.ПС;
			КонецЦикла;
			
			Проверить(Ложь,
			"Таблицы 1 и 2 должны совпадать, а они различны" + Символы.ПС + СтрокаОшибок+Символы.ПС + ДопСообщениеОшибки);
		КонецЕсли; 
	
	#Иначе 
		ВызватьИсключение "Утверждение ПроверитьРавенствоТаблиц можно использовать только на толстом клиенте, сервере или внешнем соединении!";
	#КонецЕсли 
КонецПроцедуры

//}

//{ МЕТОДЫ ДЛЯ ИСПОЛЬЗОВАНИЯ ИЗ ОБРАБОТОК ТЕСТИРОВАНИЯ

// Создает новый набор тестов.
// 
Функция Новый_НаборТестов() Экспорт
	Возврат Новый Массив;
КонецФункции

// Добавляет новый тестовый случай в набор.
// 
Функция НаборТестов_Добавить(НаборТестов, ИмяТестовогоСлучая, П1=Неопределено, П2=Неопределено, П3=Неопределено, П4=Неопределено, П5=Неопределено, П6=Неопределено, П7=Неопределено) Экспорт
	
	НаборТестов.Добавить(ИмяТестовогоСлучая);
	Возврат НаборТестов;
	
КонецФункции

// Выводит сообщение. В тестах ВСЕГДА должна использоваться ВМЕСТО метода Сообщить().
// 
Функция ВывестиСообщение(ТекстСообщения, Статус=Неопределено) Экспорт	
	
	Если mMiddleMan <> Неопределено Тогда
		Если НЕ ОповеститьОСобытии("Message", ТекстСообщения) Тогда
			ОповеститьОСобытии("ВывестиСообщение", ТекстСообщения);
		КонецЕсли;
	Иначе
		Если ВыводЛогаВФорматеTeamCity Тогда
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"|","||");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"'","|'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"[","|[");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"]","|]");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,Символы.ВК,"|r");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,Символы.ПС,"|n");		
			
			Сообщить("##teamcity[message text='"+ТекстСообщения+"' errorDetails='' status='"+мСоответствиеСтатусовДляTeamCity[Статус]+"']");
		Иначе
			Сообщить(ТекстСообщения, Статус);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

// Вызывает исключение с заданным текстом ошибки для прерывания выполнения тестового случая.
// 
Функция ПрерватьТест(ТекстОшибки) Экспорт
	
	ВызватьИсключение ТекстОшибки;
	
КонецФункции

//}

//{ ВНЕШНЕЕ API (для использования из скрипта Снегопата или из COM-подключения).

Функция OpenBrowserForm() Экспорт
	Перем НоваяФорма;
	//#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		НоваяФорма = ЭтотОбъект.ПолучитьФорму("Форма");
		НоваяФорма.Открыть();
	#ИначеЕсли НаКлиенте Тогда
		Если ЭтоВнешняяОбработка() Тогда
			НоваяФорма = ОткрытьФорму("ВнешняяОбработка."+Метаданные().Имя+".Форма.УправляемаяФорма"); 
		Иначе			
			НоваяФорма = ОткрытьФорму("Обработка."+Метаданные().Имя+".Форма.УправляемаяФорма"); 
		КонецЕсли;
	#КонецЕсли
	Возврат НоваяФорма;
КонецФункции

// Устанавливает объект-прокси, который будет получать сообщения 
// о ходе загрузки и выполнения тестов, сообщения, выводимые при 
// выполнении тестов. Для использования в скрипте для Снегопата.
// 
Функция SetHandlerObject(obj) Экспорт
	mMiddleMan = obj;
КонецФункции

// Загружает все тесты из каталога в дерево тестов.
// 
Функция LoadAllTests(ПутьККаталогу) Экспорт
	
	ДеревоТестов.Строки.Очистить();
			
	ЗагрузитьТесты(ДеревоТестов, Новый Файл(ПутьККаталогу));
		
КонецФункции

// Загружает отдельную обработку тестирования в дерево тестов.
// 
Функция LoadTest(ПутьКФайлуТеста) Экспорт
	
	ДеревоТестов.Строки.Очистить();
			
	ЗагрузитьТесты(ДеревоТестов, Новый Файл(ПутьКФайлуТеста));
		
КонецФункции

// Выполняет все тесты, загруженные в дерево тестов.
// 
Функция RunAllTests() Экспорт
    
    #Если Клиент Тогда
	ОчиститьСообщения();
    #КонецЕсли
	
	ПодчиненныеСтроки = ПодчиненныеСтроки(ДеревоТестов);
	
	Если СлучайныйПорядокВыполнения Тогда
		МассивСтрокДерева = Новый Массив();
		ПолучитьТолькоТестовыеМетодыИзДерева(ПодчиненныеСтроки, МассивСтрокДерева);
		СтрокиДерева = ПеремешатьМассив(МассивСтрокДерева);
	Иначе
		СтрокиДерева = ПодчиненныеСтроки;
	КонецЕсли; 
	
	результат = ВыполнитьТесты(СтрокиДерева);
	Возврат результат;
КонецФункции

Процедура ПолучитьТолькоТестовыеМетодыИзДерева(ПодчиненныеСтрокиДереваТестов, МассивДляДобавления)
	Для каждого СтрокаДереваТестов из ПодчиненныеСтрокиДереваТестов Цикл
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли 
		
		Если СтрокаДереваТестов.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
			
			МассивДляДобавления.Добавить(СтрокаДереваТестов);
			
		Иначе
			
			ПолучитьТолькоТестовыеМетодыИзДерева(ПодчиненныеСтроки(СтрокаДереваТестов), МассивДляДобавления);
			
		КонецЕсли;
				
	КонецЦикла;
КонецПроцедуры

Функция ПеремешатьМассив(МассивСтрокДерева) Экспорт
	Копия = Новый Массив;
	Для каждого Эл Из МассивСтрокДерева Цикл
		Копия.Добавить(Эл);
	КонецЦикла;
	РезМассив = Новый Массив;
	
	Пока Копия.Количество() > 0 Цикл
		ГСЧ = Новый ГенераторСлучайныхЧисел();
		Индекс = ГСЧ.СлучайноеЧисло(0, Копия.Количество()-1);
		РезМассив.Добавить(Копия[Индекс]);
		Копия.Удалить(Индекс);
	КонецЦикла;
	Возврат РезМассив;
КонецФункции

// Запускает отдельный тест из дерева тестов.
// 
Функция RunTest(TestRow) Экспорт
	
    #Если Клиент Тогда
	ОчиститьСообщения();
    #КонецЕсли
	
	ПередВыполнениемТестов();
	результат = ВыполнитьТест(TestRow, мСписокОшибок);
	Возврат результат;
	
КонецФункции

//}

// { Методы генерации тестовых данных

Функция СоздатьДанныеПоМакетам(ТестОбъект, ИменаМакетов) Экспорт
	МассивИменМакетов = РазложитьСтрокуВМассивПодстрок(ИменаМакетов);
	МассивМакетов = Новый Массив;
	Для каждого ИмяМакета Из МассивИменМакетов Цикл
		МассивМакетов.Добавить(ТестОбъект.ПолучитьМакет(ИмяМакета));
	КонецЦикла;
	Возврат СоздатьДанныеПоТабличномуДокументу(МассивМакетов);
КонецФункции

Функция СоздатьДанныеПоТабличномуДокументу(ТабличныйДокументИлиМассивТабличныхДокументов, ИмяКолонкиЗамещения = Неопределено) Экспорт
	МассивТабличныхДокументов = Новый Массив();
	Если ТипЗнч(ТабличныйДокументИлиМассивТабличныхДокументов) = Тип("ТабличныйДокумент") Тогда
		МассивТабличныхДокументов.Добавить(ТабличныйДокументИлиМассивТабличныхДокументов);
	ИначеЕсли ТипЗнч(ТабличныйДокументИлиМассивТабличныхДокументов) = Тип("Массив") Тогда
		МассивТабличныхДокументов = ТабличныйДокументИлиМассивТабличныхДокументов;
	КонецЕсли;
	Возврат СоздатьДанныеИзМакетов(МассивТабличныхДокументов);
КонецФункции

// удаляет созданные элементы (Справочники, Документы, Пользователи ИБ), регистры сведений не чистит - есть тесты
Функция УдалитьСозданныеДанные(Данные) Экспорт
	// обратный порядок нужен для получения правильного количества удаленных элементов, т.к Владелец.Удалить удаляет и подчиненные элементы из подчиненных справочников
	массивВОбратномПорядке = Новый Массив;
	Для каждого ключЗначение Из Данные Цикл
		массивВОбратномПорядке.Вставить(0, КлючЗначение.Значение);
	КонецЦикла;
	
	количествоУдаленных = 0;
	Для каждого элем Из массивВОбратномПорядке Цикл
		типЭлемента = ТипЗнч(элем);
		Если Справочники.ТипВсеСсылки().СодержитТип(типЭлемента) Тогда
			объект = элем.ПолучитьОбъект();
			Если объект <> Неопределено Тогда
				Попытка
					объект.Удалить();
					количествоУдаленных = количествоУдаленных + 1;
				Исключение
					Сообщить(ОписаниеОшибки());
				КонецПопытки;
			КонецЕсли; 
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(типЭлемента) Тогда
			объект = элем.ПолучитьОбъект();
			Если объект <> Неопределено Тогда
				Попытка
					объект.Удалить();
					количествоУдаленных = количествоУдаленных + 1;
				Исключение
					Сообщить(ОписаниеОшибки());
				КонецПопытки;
			КонецЕсли; 
		ИначеЕсли типЭлемента = Тип("ПользовательИнформационнойБазы") Тогда
			Попытка
				элем.Удалить();
				количествоУдаленных = количествоУдаленных + 1;
			Исключение
				Сообщить(ОписаниеОшибки());
			КонецПопытки;
		КонецЕсли; 
	КонецЦикла;
	Возврат количествоУдаленных;
КонецФункции

Функция СоздатьДанныеИзМакетов(МассивТабличныхДокументов,ИмяКолонкиЗамещения = Неопределено) //Экспорт
	ПротоДанные = Новый Структура;
	Для каждого ТабличныйДокумент Из МассивТабличныхДокументов Цикл
		ПрочитатьДанныеИзМакета(ПротоДанные,ТабличныйДокумент,ИмяКолонкиЗамещения);
	КонецЦикла;
	Данные = СоздатьТестовыеДанныеПоПротоДанным(ПротоДанные);
	Возврат Данные;
КонецФункции

Функция ПрочитатьДанныеИзМакета(ПротоДанные,ТабличныйДокумент,ИмяКолонкиЗамещения)
	
	СтрокаМакета = 1;
	НомерКолонкиМакета = 0;
	КолонкиМакета = КолонкиМакетаДанных();
	Пока НомерКолонкиМакета<ТабличныйДокумент.ШиринаТаблицы Цикл
		НомерКолонкиМакета = НомерКолонкиМакета + 1;
		ИмяКолонки = ТабличныйДокумент.Область("R" + 1 + "C" + НомерКолонкиМакета).Текст;
		Если Не ПустаяСтрока(ИмяКолонки) Тогда
			КолонкиМакета.Вставить(ИмяКолонки,НомерКолонкиМакета);
		КонецЕсли;
	КонецЦикла;
	
	ПроверитьКолонки(КолонкиМакета,ИмяКолонкиЗамещения);

	ДействиеТекущейСтроки = Неопределено;
	Пока СтрокаМакета<ТабличныйДокумент.ВысотаТаблицы Цикл
		СтрокаМакета = СтрокаМакета + 1;
		НомерСтроки = Формат(СтрокаМакета, "ЧГ=");
		
		//Если новый объект
		ИмяПеременной = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ИмяПеременной);
		Если Не ПустаяСтрока(ИмяПеременной) Тогда
			Если ПротоДанные.Свойство(ИмяПеременной) Тогда
				ВызватьИсключение "Ошибка при создании данных из макета! Неуникальное имя переменной: ["+ИмяПеременной+"]";
			КонецЕсли;
			
			Тип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Тип);
			Вид = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Вид);
			Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
			Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);			
			
			ПротоОбъект = СоздатьСтруктуруОписанияОбъекта();
			ПротоОбъект.ИмяПеременной = ИмяПеременной;
			ПротоОбъект.Тип = Тип;
			ПротоОбъект.Вид = Вид;
			ПротоОбъект.ИмяПредопределенного = Значение;
			ПротоОбъект.ПоляОбъекта = СоздатьТаблицуОписанияПолей();
			Если Не ПустаяСтрока(Режим) Тогда
				Если ПротоОбъект.Режимы.Свойство(Режим) Тогда
					ПротоОбъект.Режимы[Режим] = Истина;
				КонецЕсли;
			КонецЕсли;
			
			ПротоДанные.Вставить(ИмяПеременной,ПротоОбъект);
			ДействиеТекущейСтроки = "ЧитаемПоляОбъекта";
			Продолжить;
		КонецЕсли;
		
		//Табличные части
		ИмяТабЧасти = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ТЧ);
		Если Не ПустаяСтрока(ИмяТабЧасти) Тогда
			Если ВРег(ИмяТабЧасти)="XDDMODS" или ВРег(ИмяТабЧасти)="XDDDATAGEN" Тогда
				ДействиеТекущейСтроки = "ЧитаемРежимы";
				Продолжить;
			КонецЕсли;
			Если ВРег(ИмяТабЧасти)="ДОПОЛНИТЕЛЬНЫЕСВОЙСТВА" Тогда
				ДействиеТекущейСтроки = "ЧитаемДопСвойства";
				Продолжить;
			КонецЕсли;
			Если ВРег(ИмяТабЧасти)="ОБМЕНДАННЫМИ" Тогда
				ДействиеТекущейСтроки = "ЧитаемОбменДанными";
				Продолжить;
			КонецЕсли;
			
			ТабЧасть = Неопределено;
			Если Не ПротоОбъект.ТабличныеЧасти.Свойство(ИмяТабЧасти,ТабЧасть) Тогда
				//Новая ТабЧасть
				ОписаниеПолейТЧ = СоздатьТаблицуОписанияПолей();
				ТабЧасть = Новый Массив;
				ТабЧасть.Добавить(ОписаниеПолейТЧ);
				ПротоОбъект.ТабличныеЧасти.Вставить(ИмяТабЧасти,ТабЧасть);
				ДействиеТекущейСтроки = "ЧитаемТабЧасть";
				Продолжить;
			Иначе
				//Новая строка ТабЧасти
				ОписаниеПолейТЧ = СоздатьТаблицуОписанияПолей();
				ТабЧасть.Добавить(ОписаниеПолейТЧ);
				ДействиеТекущейСтроки = "ЧитаемТабЧасть";
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		//Поля объекта
		Если ДействиеТекущейСтроки = "ЧитаемПоляОбъекта" Тогда
			ИмяРеквизита = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяРеквизита) Тогда
				НовоеПолеОбъекта = ПротоОбъект.ПоляОбъекта.Добавить();
				НовоеПолеОбъекта.Имя = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Реквизит);
				НовоеПолеОбъекта.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеОбъекта.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеОбъекта.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		//Поля табличной части
		Если ДействиеТекущейСтроки = "ЧитаемТабЧасть" Тогда
			ИмяРеквизитаТЧ = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяРеквизитаТЧ) Тогда
				НовоеПолеТЧ = ОписаниеПолейТЧ.Добавить();
				НовоеПолеТЧ.Имя = ИмяРеквизитаТЧ;
				НовоеПолеТЧ.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеТЧ.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеТЧ.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		//Режимы объекта
		Если ДействиеТекущейСтроки = "ЧитаемРежимы" Тогда
			КодРежима = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Реквизит);
			Режим = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
			Если ВРег(КодРежима)="РЕЖИМ" Тогда
				Если ПротоОбъект.Режимы.Свойство(Режим) Тогда
					ПротоОбъект.Режимы[Режим] = Истина;
				КонецЕсли;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		//Дополнительные свойства
		Если ДействиеТекущейСтроки = "ЧитаемДопСвойства" Тогда
			ИмяДопСвойства = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяДопСвойства) Тогда
				НовоеПолеДопСвойств = ПротоОбъект.ДопСвойства.Добавить();
				НовоеПолеДопСвойств.Имя = ИмяДопСвойства;
				НовоеПолеДопСвойств.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеДопСвойств.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеДопСвойств.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Если ДействиеТекущейСтроки = "ЧитаемОбменДанными" Тогда
			ИмяОбменДанными = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяОбменДанными) Тогда
				НовоеПолеОбменаДанными = ПротоОбъект.ОбменДанными.Добавить();
				НовоеПолеОбменаДанными.Имя = ИмяОбменДанными;
				НовоеПолеОбменаДанными.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеОбменаДанными.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеОбменаДанными.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция ПроверитьКолонки(КолонкиМакета,ИмяКолонкиЗамещения)
	Для каждого Колонка Из КолонкиМакета Цикл
		Если Колонка.Значение = "0" Тогда
			Если Колонка.Ключ = "ДополнительныйТипЗначения" Тогда
				//Это не обязательная колонка - может быть и не заполнена
			Иначе
				ВызватьИсключение "Неверно задан макет. Неверная колонка в первой строке. Не указана обязательная колонка с именем ["+Колонка.Ключ+"]";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(ИмяКолонкиЗамещения) Тогда
		Если не КолонкиМакета.Свойство(ИмяКолонкиЗамещения) Тогда
			ВызватьИсключение "Указанное Имя колонки замещения ["+ИмяКолонкиЗамещения+"] не существует в макете.";
		КонецЕсли;
	КонецЕсли;
КонецФункции

Функция ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения)
	Значение = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Значение);
	Если ЗначениеЗаполнено(ИмяКолонкиЗамещения) Тогда
		ПриоритетноеЗначение = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета[ИмяКолонкиЗамещения]);
		Если ЗначениеЗаполнено(ПриоритетноеЗначение) Тогда
			Значение = ПриоритетноеЗначение;
		КонецЕсли;
	КонецЕсли;
	Возврат Значение;
КонецФункции

Функция ПрочитатьЗначениеЯчейкиМакета(Макет,НомерСтроки,НомерКолонки);
	ТекстЯчейки = Неопределено;
	Если НомерСтроки<> "0" И НомерКолонки <> "0" Тогда
		ТекстЯчейки = Макет.Область("R" + НомерСтроки + "C" + НомерКолонки).Текст;
	КонецЕсли;
	Возврат ТекстЯчейки;
КонецФункции

Функция СоздатьСтруктуруОписанияОбъекта()
	СтруктураОписанияОбъекта = Новый Структура();
	СтруктураОписанияОбъекта.Вставить("Объект",Неопределено);
	СтруктураОписанияОбъекта.Вставить("Тип",Неопределено);
	СтруктураОписанияОбъекта.Вставить("Вид",Неопределено);
	СтруктураОписанияОбъекта.Вставить("ИмяПредопределенного",Неопределено);
	СтруктураОписанияОбъекта.Вставить("ИмяПеременной",Неопределено);
	СтруктураОписанияОбъекта.Вставить("Режимы",СоздатьСтруктуруРежимовОбъекта());
	СтруктураОписанияОбъекта.Вставить("ПоляОбъекта",СоздатьТаблицуОписанияПолей());
	СтруктураОписанияОбъекта.Вставить("ТабличныеЧасти",Новый Структура);
	СтруктураОписанияОбъекта.Вставить("ДопСвойства",СоздатьТаблицуОписанияПолей());
	СтруктураОписанияОбъекта.Вставить("ОбменДанными",СоздатьТаблицуОписанияПолей());
	Возврат СтруктураОписанияОбъекта;
КонецФункции

Функция СоздатьСтруктуруРежимовОбъекта()
	Режимы = новый Структура;
	Режимы.Вставить("Предопределенный",Ложь);
	Режимы.Вставить("СоздатьПоГуид",Ложь);
	Режимы.Вставить("ТолькоСоздание",Ложь);
	Режимы.Вставить("Проведение",Ложь);
	Режимы.Вставить("ОбменДанными",Ложь);
	Режимы.Вставить("Объект",Ложь);
	Режимы.Вставить("Группа",Ложь);
	Возврат Режимы;
КонецФункции

Функция СоздатьТаблицуОписанияПолей()
	тзОписаниеПолей = Новый ТаблицаЗначений;
	тзОписаниеПолей.Колонки.Добавить("Имя");
	тзОписаниеПолей.Колонки.Добавить("Значение");
	тзОписаниеПолей.Колонки.Добавить("Режим");
	тзОписаниеПолей.Колонки.Добавить("ДополнительныйТип");
	Возврат тзОписаниеПолей;
КонецФункции

Функция МенеджерыМетаданных()
	Менеджеры = новый Структура;
	Менеджеры.Вставить("Справочник",Справочники);
	Менеджеры.Вставить("Документ",Документы);
	Менеджеры.Вставить("БизнесПроцесс",БизнесПроцессы);
	Менеджеры.Вставить("Задача",Задачи);
	Менеджеры.Вставить("РегистрСведений",РегистрыСведений);
	Менеджеры.Вставить("РегистрНакопления",РегистрыНакопления);
	Менеджеры.Вставить("ПланВидовХарактеристик",ПланыВидовХарактеристик);
	Менеджеры.Вставить("ПользовательИБ",ПользователиИнформационнойБазы);
	Возврат Новый ФиксированнаяСтруктура(Менеджеры);
КонецФункции

Функция СоздатьТестовыеДанныеПоПротоДанным(ПротоДанные)
	Данные = Новый Структура;
	МенеджерыМетаданных = МенеджерыМетаданных();
	Для каждого ПротоОбъект из ПротоДанные Цикл
		ОбъектСсылка = ПолучитьОбъект(ПротоДанные,ПротоОбъект.Значение);
		Данные.Вставить(ПротоОбъект.Значение.ИмяПеременной,ОбъектСсылка);
	КонецЦикла;
	Возврат Данные;
КонецФункции

Функция ПолучитьОбъект(ПротоДанные,ПротоОбъект)
	ОбъектСсылка = Неопределено;
	Если ПротоОбъект.Объект<>Неопределено Тогда
		Возврат ПротоОбъект.Объект;
	ИначеЕсли ПротоОбъект.Тип = "Справочник" Тогда
		ОбъектСсылка = СоздатьОбъект_Справочник(ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "Документ" Тогда
		ОбъектСсылка = СоздатьОбъект_Документ(ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "БизнесПроцесс" Тогда
		ОбъектСсылка = СоздатьОбъект_БизнесПроцесс(ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "Задача" Тогда
		ОбъектСсылка = СоздатьОбъект_Задача(ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "РегистрСведений" Тогда
		ОбъектСсылка = СоздатьОбъект_РегистрСведений(ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "РегистрНакопления" Тогда
		ОбъектСсылка = СоздатьОбъект_РегистрНакопления(ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "ПользовательИБ" Тогда
		ОбъектСсылка = СоздатьОбъект_ПользовательИБ(ПротоДанные,ПротоОбъект);
	КонецЕсли;
	ПротоОбъект.Объект = ОбъектСсылка;
	Возврат ОбъектСсылка;
КонецФункции

Функция СоздатьОбъект_Справочник(ПротоДанные,ПротоОбъект)
	СпрМенеджер = Справочники[ПротоОбъект.Вид];
	
	//Подготовим ПротоОбъект
	стрПолеЭтоГруппа = ПротоОбъект.ПоляОбъекта.Найти("ЭтоГруппа","Имя");
	Если стрПолеЭтоГруппа<>Неопределено Тогда
		ПротоОбъект.Режимы.Группа = Булево(стрПолеЭтоГруппа.Значение);
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеЭтоГруппа);
	КонецЕсли;
	стрПолеСсылка = ПротоОбъект.ПоляОбъекта.Найти("Ссылка","Имя");
	Если стрПолеСсылка<>Неопределено Тогда
		ПротоОбъект.Объект = СпрМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(стрПолеСсылка.Значение));
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеСсылка);
		Объект = ПротоОбъект.Объект.ПолучитьОбъект();
		Если ПротоОбъект.Режимы.ТолькоСоздание И Объект<>Неопределено Тогда
			Возврат ПротоОбъект.Объект;
		КонецЕсли;
	КонецЕсли;
	
	
	//Создание объекта справочника
	Если Объект=Неопределено Тогда
		Если ПротоОбъект.Режимы.Предопределенный Тогда
			Попытка
				Объект = СпрМенеджер[ПротоОбъект.ИмяПредопределенного].ПолучитьОбъект();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "Справочник."+ПротоОбъект.Вид+" не удалось найти предопределенный элемент/группу ["+ПротоОбъект.ИмяПредопределенного+"]."+Символы.ПС+Ошибка;
			КонецПопытки;
		ИначеЕсли ПротоОбъект.Режимы.СоздатьПоГуид Тогда
			ВызватьИсключение "Устарело и больше не поддерживается: https://github.com/xDrivenDevelopment/xUnitFor1C/issues/332";
		ИначеЕсли ПротоОбъект.Режимы.Группа Тогда
			Попытка
				Объект = СпрМенеджер.СоздатьГруппу();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "Справочник."+ПротоОбъект.Вид+" не удалось создать новую группу."+Символы.ПС+Ошибка;
			КонецПопытки;
		Иначе
			Попытка
				Объект = СпрМенеджер.СоздатьЭлемент();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "Справочник."+ПротоОбъект.Вид+" не удалось создать новый элемент."+Символы.ПС+Ошибка;
			КонецПопытки;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПротоОбъект.Объект) и Объект.ЭтоНовый() Тогда
			Объект.УстановитьСсылкуНового(ПротоОбъект.Объект);
		КонецЕсли;
	КонецЕсли;
	
	//Заполняем реквизиты справочника
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого мдТабЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		ЭтоРежимГруппа = ПротоОбъект.Режимы.Группа;
		Если (ЭтоРежимГруппа И мдТабЧасть.Использование<>Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			Или (Не ЭтоРежимГруппа И мдТабЧасть.Использование<>Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
			
				Объект[мдТабЧасть.Имя].Очистить();
		КонецЕсли;
		 
	КонецЦикла;
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Код) тогда
		Объект.УстановитьНовыйКод();
	КонецЕсли;
	Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	
	//Дополнительные Свойства
	Для каждого стрДопСвойство Из ПротоОбъект.ДопСвойства Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ДополнительныеСвойства.Вставить(стрДопСвойство.Имя,Значение);
	КонецЦикла;
	Для каждого стрДопСвойство Из ПротоОбъект.ОбменДанными Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ОбменДанными[стрДопСвойство.Имя] = Значение;
	КонецЦикла;
	
	//Запись объекта
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Объект.Записать();
			Результат = Объект.Ссылка;
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи справочника "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	Иначе
		Результат = Объект;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъект_Документ(ПротоДанные,ПротоОбъект)
	
	//Подготовим ПротоОбъект
	стрПолеСсылка = ПротоОбъект.ПоляОбъекта.Найти("Ссылка","Имя");
	Если стрПолеСсылка<>Неопределено Тогда
		ПротоОбъект.Объект = Документы[ПротоОбъект.Вид].ПолучитьСсылку(Новый УникальныйИдентификатор(стрПолеСсылка.Значение));
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеСсылка);
		Объект = ПротоОбъект.Объект.ПолучитьОбъект();
		Если ПротоОбъект.Режимы.ТолькоСоздание И Объект<>Неопределено Тогда
			Возврат ПротоОбъект.Объект;
		КонецЕсли;
	КонецЕсли;
	
	//Создание объекта
	Попытка
		Объект = Документы[ПротоОбъект.Вид].СоздатьДокумент();
	Исключение
		Ошибка = ОписаниеОшибки();
		ВызватьИсключение "Документ."+ПротоОбъект.Вид+" не удалось создать новый документ."+Символы.ПС+Ошибка;
	КонецПопытки;
	
	//Установка ссылки
	Если ЗначениеЗаполнено(ПротоОбъект.Объект) и Объект.ЭтоНовый() Тогда
		Объект.УстановитьСсылкуНового(ПротоОбъект.Объект);
	КонецЕсли;
	
	//Заполняем реквизиты
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого мдТабЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		Объект[мдТабЧасть.Имя].Очистить();
	КонецЦикла;
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Дата) Тогда
		Объект.Дата = ТекущаяДата();
	КонецЕсли;			
	Если Не ЗначениеЗаполнено(Объект.Номер) тогда
		Объект.УстановитьНовыйНомер();
	КонецЕсли;
	Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	
	//Дополнительные Свойства
	Для каждого стрДопСвойство Из ПротоОбъект.ДопСвойства Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ДополнительныеСвойства.Вставить(стрДопСвойство.Имя,Значение);
	КонецЦикла;
	Для каждого стрДопСвойство Из ПротоОбъект.ОбменДанными Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ОбменДанными[стрДопСвойство.Имя] = Значение;
	КонецЦикла;
	
	//Запись документа
	Если Не ПротоОбъект.Режимы.Объект Тогда
		РежимЗаписи = РежимЗаписиДокумента.Запись;
		Если ПротоОбъект.Режимы.Проведение Тогда
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
		КонецЕсли;
		Попытка
			Объект.Записать(РежимЗаписи);
			Результат = Объект.Ссылка;
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи документа "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	Иначе
		Результат = Объект;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъект_БизнесПроцесс(ПротоДанные,ПротоОбъект)
	
	//Подготовим ПротоОбъект
	стрПолеСсылка = ПротоОбъект.ПоляОбъекта.Найти("Ссылка","Имя");
	Если стрПолеСсылка<>Неопределено Тогда
		ПротоОбъект.Объект = БизнесПроцессы[ПротоОбъект.Вид].ПолучитьСсылку(Новый УникальныйИдентификатор(стрПолеСсылка.Значение));
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеСсылка);
		Объект = ПротоОбъект.Объект.ПолучитьОбъект();
		Если ПротоОбъект.Режимы.ТолькоСоздание И Объект<>Неопределено Тогда
			Возврат ПротоОбъект.Объект;
		КонецЕсли;
	КонецЕсли;
	
	//Создание объекта
	Попытка
		Объект = БизнесПроцессы[ПротоОбъект.Вид].СоздатьБизнесПроцесс();
	Исключение
		Ошибка = ОписаниеОшибки();
		ВызватьИсключение "БизнесПроцесс."+ПротоОбъект.Вид+" не удалось создать новый бизнес процесс."+Символы.ПС+Ошибка;
	КонецПопытки;
	
	//Заполняем реквизиты объекта
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого мдТабЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		Объект[мдТабЧасть.Имя].Очистить();
	КонецЦикла;
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Дата) Тогда
		Объект.Дата = ТекущаяДата();
	КонецЕсли;			
	Если Не ЗначениеЗаполнено(Объект.Номер) тогда
		Объект.УстановитьНовыйНомер();
	КонецЕсли;
	Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	
	//Дополнительные Свойства
	Для каждого стрДопСвойство Из ПротоОбъект.ДопСвойства Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ДополнительныеСвойства.Вставить(стрДопСвойство.Имя,Значение);
	КонецЦикла;
	Для каждого стрДопСвойство Из ПротоОбъект.ОбменДанными Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ОбменДанными[стрДопСвойство.Имя] = Значение;
	КонецЦикла;
	
	//Запись объекта
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Объект.Записать();
			Результат = Объект.Ссылка;
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи БизнесПроцесса "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	Иначе
		Результат = Объект;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъект_Задача(ПротоДанные,ПротоОбъект)
	
	//Подготовим ПротоОбъект
	стрПолеСсылка = ПротоОбъект.ПоляОбъекта.Найти("Ссылка","Имя");
	Если стрПолеСсылка<>Неопределено Тогда
		ПротоОбъект.Объект = Задачи[ПротоОбъект.Вид].ПолучитьСсылку(Новый УникальныйИдентификатор(стрПолеСсылка.Значение));
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеСсылка);
		Объект = ПротоОбъект.Объект.ПолучитьОбъект();
		Если ПротоОбъект.Режимы.ТолькоСоздание И Объект<>Неопределено Тогда
			Возврат ПротоОбъект.Объект;
		КонецЕсли;
	КонецЕсли;
	
	//Создание объекта
	Попытка
		Объект = Задачи[ПротоОбъект.Вид].СоздатьЗадачу();
	Исключение
		Ошибка = ОписаниеОшибки();
		ВызватьИсключение "Задача."+ПротоОбъект.Вид+" не удалось создать новую задачу."+Символы.ПС+Ошибка;
	КонецПопытки;	
	
	//Заполняем реквизиты объекта
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого мдТабЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		Объект[мдТабЧасть.Имя].Очистить();
	КонецЦикла;
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Дата) Тогда
		Объект.Дата = ТекущаяДата();
	КонецЕсли;			
	Если Не ЗначениеЗаполнено(Объект.Номер) тогда
		Объект.УстановитьНовыйНомер();
	КонецЕсли;
	Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	
	//Дополнительные Свойства
	Для каждого стрДопСвойство Из ПротоОбъект.ДопСвойства Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ДополнительныеСвойства.Вставить(стрДопСвойство.Имя,Значение);
	КонецЦикла;
	Для каждого стрДопСвойство Из ПротоОбъект.ОбменДанными Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ОбменДанными[стрДопСвойство.Имя] = Значение;
	КонецЦикла;
	
	//Запись Объекта
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Объект.Записать();
			Результат = Объект.Ссылка;
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи Задачи "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	Иначе
		Результат = Объект;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъект_РегистрСведений(ПротоДанные,ПротоОбъект)
	
	//Создание объекта
	ПротоНаборЗаписей = Неопределено;
	Если ПротоОбъект.ТабличныеЧасти.Свойство("Запись",ПротоНаборЗаписей) Тогда
		Попытка
			Объект = РегистрыСведений[ПротоОбъект.Вид].СоздатьНаборЗаписей();
		Исключение
			Ошибка = ОписаниеОшибки();
			ВызватьИсключение "РегистрыСведений."+ПротоОбъект.Вид+" не удалось создать новый набор записей."+Символы.ПС+Ошибка;
		КонецПопытки;
		
		МетаданныеНабора = Объект.Метаданные();
		НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, МетаданныеНабора);
		РегистрСведенийПодчиненРегистратору = МетаданныеНабора.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору;
		
		Для каждого СтрокаЗаписи Из ПротоНаборЗаписей Цикл
			ЗаписьНабора = Объект.Добавить();
			Для каждого стрПоле Из СтрокаЗаписи Цикл
				ЗаписьНабора[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
			КонецЦикла;
			
			Если РегистрСведенийПодчиненРегистратору Тогда
				ПроверитьЗаполненность(ЗаписьНабора.Регистратор, "Не задан регистратор для записей регистра сведений. Переменная "+ПротоОбъект.ИмяПеременной);
				Если НЕ ЗначениеЗаполнено(ЗаписьНабора.Период) Тогда
					ЗаписьНабора.Период = ЗаписьНабора.Регистратор.Дата;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		//Установка Отборов регистра
		РегистрСведенийПодчиненРегистратору = МетаданныеНабора.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору;
		Если РегистрСведенийПодчиненРегистратору Тогда
			ЗаписьНабора = Объект[0];
			Объект.Отбор.Регистратор.Установить(ЗаписьНабора.Регистратор);
		Иначе
			Для каждого МетаИзмерение Из МетаданныеНабора.Измерения Цикл
				ЗаписьНабора = Объект[0];
				ИмяИзмерения = МетаИзмерение.Имя;
				Если Объект.Отбор.Найти(ИмяИзмерения)	<> Неопределено Тогда
					Объект.Отбор[ИмяИзмерения].Установить(ЗаписьНабора[ИмяИзмерения]);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	Иначе
		Попытка
			Объект = РегистрыСведений[ПротоОбъект.Вид].СоздатьМенеджерЗаписи();
		Исключение
			Ошибка = ОписаниеОшибки();
			ВызватьИсключение "РегистрыСведений."+ПротоОбъект.Вид+" не удалось создать"+Символы.ПС+Ошибка;
		КонецПопытки;
		
		НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, РегистрыСведений[ПротоОбъект.Вид].СоздатьНаборЗаписей().Метаданные());
		Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
			Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
		КонецЦикла;
	КонецЕсли;
	
	//Запись объекта
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Объект.Записать();
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи справочника "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Объект;
КонецФункции

Функция СоздатьОбъект_РегистрНакопления(ПротоДанные,ПротоОбъект)
	
	//Создание объекта
	ПротоНаборЗаписей = Неопределено;
	Если ПротоОбъект.ТабличныеЧасти.Свойство("Запись",ПротоНаборЗаписей) Тогда
		Попытка
			Объект = РегистрыНакопления[ПротоОбъект.Вид].СоздатьНаборЗаписей();
		Исключение
			Ошибка = ОписаниеОшибки();
			ВызватьИсключение "РегистрыНакопления."+ПротоОбъект.Вид+" не удалось создать новый НаборЗаписей."+Символы.ПС+Ошибка;
		КонецПопытки;
		
		МетаданныеНабора = Объект.Метаданные();
		НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, МетаданныеНабора);
		
		Для каждого СтрокаЗаписи Из ПротоНаборЗаписей Цикл
			ЗаписьНабора = Объект.Добавить();
			Для каждого стрПоле Из СтрокаЗаписи Цикл
				ЗаписьНабора[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
			КонецЦикла;
			
			ПроверитьЗаполненность(ЗаписьНабора.Регистратор, "Не задан регистратор для записей регистра накопления. Переменная "+ПротоОбъект.ИмяПеременной);
			Если НЕ ЗначениеЗаполнено(ЗаписьНабора.Период) Тогда
				ЗаписьНабора.Период = ЗаписьНабора.Регистратор.Дата;
			КонецЕсли;
		КонецЦикла;
		
		Объект.Отбор.Регистратор.Установить(ЗаписьНабора.Регистратор);
		Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	Иначе
		ВызватьИсключение "РегистрыНакопления."+ПротоОбъект.Вид+" в макете нет записей для регистра накопления.";
	КонецЕсли;
	
	//Запись объекта
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Объект.Записать();
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи справочника "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Объект;
КонецФункции

Функция СоздатьОбъект_ПользовательИБ(ПротоДанные,ПротоОбъект);
	Объект = ПользователиИнформационнойБазы.СоздатьПользователя();
	
	параметрыПользователя = Новый Структура;
	параметрыПользователя.Вставить("Имя", "");
	параметрыПользователя.Вставить("ПолноеИмя", "");
	параметрыПользователя.Вставить("АутентификацияСтандартная", Истина);
	параметрыПользователя.Вставить("АутентификацияОС", Ложь);
	параметрыПользователя.Вставить("ПользовательОС", "");
	параметрыПользователя.Вставить("ОсновнойИнтерфейс", ""); //Метаданные.Интерфейсы.Администратор);
	параметрыПользователя.Вставить("Пароль", "пароль");
	параметрыПользователя.Вставить("ПоказыватьВСпискеВыбора", Истина);
	параметрыПользователя.Вставить("РежимЗапуска", РежимЗапускаКлиентскогоПриложения.Авто);
	параметрыПользователя.Вставить("Язык", Метаданные.Языки.Русский);
	массивРолей = Новый Массив;
	параметрыПользователя.Вставить("Роли", массивРолей);
	
	//Заполняем реквизиты справочника
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		параметрыПользователя[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,Неопределено);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Объект, параметрыПользователя,, "ОсновнойИнтерфейс,РежимЗапуска");
	
	ПротоНаборРолей = Неопределено;
	Если ПротоОбъект.ТабличныеЧасти.Свойство("Роли",ПротоНаборРолей) Тогда
		Для каждого СтрокаРоли Из ПротоНаборРолей Цикл
			Для каждого стрПоле Из СтрокаРоли Цикл
				Роль = Метаданные.Роли.Найти(ПолучитьЗначениеПоля(ПротоДанные,стрПоле,Неопределено));
				параметрыПользователя.Роли.Добавить(Роль);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	НашлиРежимЗапуска = Ложь;
	Для каждого ЗначениеРежимаЗапуска Из РежимЗапускаКлиентскогоПриложения Цикл
		Если НРег(""+ЗначениеРежимаЗапуска) = НРег(параметрыПользователя.РежимЗапуска) Тогда
			НашлиРежимЗапуска = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если НашлиРежимЗапуска Тогда
		Объект.РежимЗапуска = ЗначениеРежимаЗапуска;
	Иначе
		ВызватьИсключение "Не нашли режим запуска <"+параметрыПользователя.РежимЗапуска+">. Возможно, нужно указать с пробелом, например, ""Управляемое приложение""";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(параметрыПользователя.ОсновнойИнтерфейс) Тогда
		Объект.ОсновнойИнтерфейс = Метаданные.Интерфейсы.Найти(параметрыПользователя.ОсновнойИнтерфейс);
	КонецЕсли;
	Для каждого роль Из параметрыПользователя.Роли Цикл
		Объект.Роли.Добавить(роль);
	КонецЦикла;
	
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Объект.Записать();
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи пользователя ИБ "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Объект;
КонецФункции

Функция ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов)
	Значение = Неопределено;
	Если ПустаяСтрока(стрПоле.Режим) Тогда
		Если ЗначениеЗаполнено(стрПоле.ДополнительныйТип) Тогда
			ТипЗначения = Новый ОписаниеТипов(стрПоле.ДополнительныйТип);
			Значение = ТипЗначения.ПривестиЗначение(стрПоле.Значение);
		Иначе
			Значение = стрПоле.Значение;
		КонецЕсли;
	ИначеЕсли ВРег(стрПоле.Режим) = "ПЕРЕМ" Тогда
		Значение = ПолучитьОбъект(ПротоДанные,ПротоДанные[стрПоле.Значение]);
		
		Если Не ЗначениеЗаполнено(Значение) Тогда
			ВызватьИсключение "ЗначениеНеНайдено: Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+">, но не нашли!";
		КонецЕсли;
	ИначеЕсли ВРег(стрПоле.Режим) = "ТЕКУЩАЯДАТА" Тогда
		Значение = ТекущаяДата();
	Иначе
		Значение = ВычислитьЗначениеПоТипуПоля(НаборМдРеквизитов,стрПоле);
	КонецЕсли;
	Возврат Значение;
КонецФункции

Функция ВычислитьЗначениеПоТипуПоля(НаборМдРеквизитов,стрПоле)
	Значение = Неопределено;
	Режим = ВРег(стрПоле.Режим);
	
	Попытка
		Если НаборМдРеквизитов = Неопределено Тогда
			Если НЕ ЗначениеЗаполнено(стрПоле.ДополнительныйТип) Тогда
				ВызватьИсключение "Не указан дополнительный тип значения";
			КонецЕсли;
			МетаданныеРеквизита = Неопределено;
		Иначе
			МетаданныеРеквизита = НаборМдРеквизитов[стрПоле.Имя];
		КонецЕсли; 
		УжеВычислилиЗначение = Ложь;
		Если Режим = "ГУИД" И МетаданныеРеквизита <> Неопределено И МетаданныеРеквизита.Тип.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
			Значение = Новый УникальныйИдентификатор(стрПоле.Значение);
			УжеВычислилиЗначение = Истина;
		Иначе
			
			Если ЗначениеЗаполнено(стрПоле.ДополнительныйТип) Тогда
				ТипЗначения = Новый ОписаниеТипов(стрПоле.ДополнительныйТип);
			Иначе
				ТипЗначения = МетаданныеРеквизита.Тип;
			КонецЕсли;
			ЗначениеПоУмолчанию = ТипЗначения.ПривестиЗначение();
			ЕстьМетаданныеРеквизита = Истина;
			Попытка
				МетаданныеТипаРеквизита = ЗначениеПоУмолчанию.Метаданные();
			Исключение
				ЕстьМетаданныеРеквизита = Ложь;
			КонецПопытки;
			Если Не ЕстьМетаданныеРеквизита И Режим = "ПРЕДОПРЕДЕЛЕННЫЙ" Тогда
				Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип( ТипЗначения.Типы()[0] ) Тогда
					Значение = ПолучитьЗначениеТочкиБизнесПроцесса(стрПоле.Значение);
					УжеВычислилиЗначение = Истина;
				Иначе
					Значение = Неопределено;
					СтрокаДляВыполнения = "Значение = "+ТипЗначения+"["""+стрПоле.Значение+"""];";
					Выполнить(СтрокаДляВыполнения);
					УжеВычислилиЗначение = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если Не УжеВычислилиЗначение Тогда
			ПолноеИмяТипаРеквизита = МетаданныеТипаРеквизита.ПолноеИмя();
			
			Если Найти(ПолноеИмяТипаРеквизита, "Справочник") = 1 Тогда
				менеджерОбъекта = Справочники[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "Документ") = 1 Тогда
				менеджерОбъекта = Документы[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "Перечисление") = 1 Тогда
				менеджерОбъекта = Перечисления[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "ПланСчетов") = 1 Тогда
				менеджерОбъекта = ПланыСчетов[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "ПланВидовХарактеристик") = 1 Тогда
				менеджерОбъекта = ПланыВидовХарактеристик[МетаданныеТипаРеквизита.Имя];
			КонецЕсли;
			ПроверитьНеРавенство(менеджерОбъекта, Неопределено, "не найден менеджерОбъекта");
			
			Если Режим = "ПРЕДОПРЕДЕЛЕННЫЙ" Тогда
				Значение = менеджерОбъекта[стрПоле.Значение];
			ИначеЕсли Режим = "КОД" Тогда
				Значение = менеджерОбъекта.НайтиПоКоду(стрПоле.Значение);
			ИначеЕсли Режим = "НОМЕР" Тогда
				Значение = НайтиБлижайшийДокументПоНомеру(МетаданныеТипаРеквизита, стрПоле.Значение);
			ИначеЕсли Режим = "НАИМЕНОВАНИЕ" Тогда
				Значение = менеджерОбъекта.НайтиПоНаименованию(стрПоле.Значение, Истина);
			ИначеЕсли Режим = "ГУИД" Тогда
				Значение = менеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор(стрПоле.Значение));
			Иначе
				ВызватьИсключение "НеверныйРежимПоиска: Не поддерживаемый режим поиска. Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+">";
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(Значение) Тогда
				ВызватьИсключение "ЗначениеНеНайдено: Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+">, но не нашли!";
			КонецЕсли;
		КонецЕсли;
	Исключение
		ошибка = ОписаниеОшибки();
		Если Найти(ошибка, "НеверныйРежимПоиска") = 0 Тогда
			ошибка = "ОшибкаПоиска:  Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+"> " + ошибка;
		КонецЕсли;
		ВызватьИсключение ошибка;
	КонецПопытки;
		
	Возврат Значение;
КонецФункции

Функция СоздатьПользователяИБ(параметры) Экспорт
	НовыйПользователь = ПользователиИнформационнойБазы.СоздатьПользователя();

	ЗаполнитьЗначенияСвойств(НовыйПользователь, параметры,, "ОсновнойИнтерфейс");
	Если ЗначениеЗаполнено(параметры.ОсновнойИнтерфейс) Тогда
		НовыйПользователь.ОсновнойИнтерфейс = Метаданные.Интерфейсы.Найти(параметры.ОсновнойИнтерфейс);
	КонецЕсли;
	Для каждого роль Из параметры.Роли Цикл
		НовыйПользователь.Роли.Добавить(роль);
	КонецЦикла;

	НовыйПользователь.Записать();  
	Возврат НовыйПользователь;
КонецФункции

Функция КолонкиМакетаДанных()
	КолонкиМакета = Новый Структура();
	КолонкиМакета.Вставить("Тип", "0");
	КолонкиМакета.Вставить("Вид", "0");
	КолонкиМакета.Вставить("ИмяПеременной", "0");
	КолонкиМакета.Вставить("ТЧ", "0");
	КолонкиМакета.Вставить("Реквизит", "0");
	КолонкиМакета.Вставить("Значение", "0");
	КолонкиМакета.Вставить("Режим", "0");
	КолонкиМакета.Вставить("ДополнительныйТипЗначения", "0");
	Возврат КолонкиМакета;
КонецФункции

Функция ПолучитьЗначениеТочкиБизнесПроцесса(Значение_Строкой)
	Значение = Неопределено;
	Для каждого БизнесПроцессМенеджер из БизнесПроцессы Цикл
		ТочкиМаршрута = БизнесПроцессМенеджер.ТочкиМаршрута;
		Для каждого ТочкаМаршрута Из ТочкиМаршрута Цикл
			Если ВРег(ТочкаМаршрута.Имя) = ВРег(Значение_Строкой) Тогда
				Значение = ТочкаМаршрута;
				Возврат Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Возврат Значение;
КонецФункции

Функция НайтиБлижайшийДокументПоНомеру(МетаданныеДокумента, Значение_Строкой)

	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Доки.Ссылка,
		|	Доки.Дата
		|ИЗ
		|	Документ."+МетаданныеДокумента.Имя+" КАК Доки
		|ГДЕ
		|	Доки.Номер = &Номер
		|
		|УПОРЯДОЧИТЬ ПО
		|	Доки.Дата УБЫВ";
	Запрос = Новый Запрос(ТекстЗапроса);
	Если МетаданныеДокумента.ТипНомера = Метаданные.СвойстваОбъектов.ТипНомераДокумента.Число Тогда
		Номер = Число(Значение_Строкой);
	Иначе
		Номер = Значение_Строкой;
	КонецЕсли; 
	Запрос.УстановитьПараметр("Номер", Номер);
	
	Результат = Запрос.Выполнить();
	
	Значение = Неопределено;
	
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Значение = ВыборкаДетальныеЗаписи.Ссылка;
	Иначе
		ВызватьИсключение "Не удалось найти документ по номеру <"+Значение_Строкой+">. Тип Документ."+МетаданныеДокумента.Имя;	
	КонецЕсли;

	Возврат Значение;
КонецФункции

Функция НаборРеквизитовМетаданных(КорневойТип, МетаданныеОбъекта)
	НаборМдРеквизитов = Новый Структура;
	Если КорневойТип = "Справочник" 
			или КорневойТип = "Документ" 
			или КорневойТип = "БизнесПроцесс"
			или КорневойТип = "ПланВидовХарактеристик" Тогда
			
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);
	ИначеЕсли КорневойТип = "Задача" Тогда
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.РеквизитыАдресации, НаборМдРеквизитов);
		
	ИначеЕсли КорневойТип = "РегистрСведений" Тогда
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Измерения, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Ресурсы, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);

	ИначеЕсли КорневойТип = "РегистрНакопления" Тогда
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Измерения, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Ресурсы, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);

	Иначе
		ВызватьИсключение "Необрабатываемый корневой тип <"+КорневойТип+">";
	КонецЕсли;
	Возврат НаборМдРеквизитов;
КонецФункции

Процедура ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МдРеквизиты, НаборМдРеквизитов)
	Для каждого МдРеквизит Из МдРеквизиты Цикл
		НаборМдРеквизитов.Вставить(МдРеквизит.Имя, МдРеквизит);
	КонецЦикла;
КонецПроцедуры

// }

//{ Методы проверки таблиц метаданных
Функция ПолучитьКоличествоДокументовПоОтбору(видДокумента, Дата1, дата2, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(видДокумента, "видДокумента");
		ПроверитьЗаполненность(Дата1, "Дата1");
		ПроверитьЗаполненность(Дата2, "Дата2");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Доки.Ссылка) КАК КоличествоДокументов
	|ИЗ
	|	Документ."+видДокумента+" КАК Доки
	|ГДЕ
	|	Доки.Ссылка.Дата МЕЖДУ &Дата1 И &Дата2
	//|	И НЕ Доки.ПометкаУдаления
	//|	И ВЫБОР КОГДА &ТолькоПроведенные ТОГДА Доки.Проведен ИНАЧЕ ИСТИНА КОНЕЦ 
	|";
	Запрос.УстановитьПараметр("Дата1", Дата1);
	Запрос.УстановитьПараметр("Дата2", КонецДня(Дата2));
	//Запрос.УстановитьПараметр("ТолькоПроведенные", ТолькоПроведенные);
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки."+имяРеквизита+" = &"+имяРеквизита+" ";
			//Запрос.Текст = Запрос.Текст + " И ВЫБОР КОГДА НЕ &"+имяРеквизита+" ЕСТЬ NULL ТОГДА Доки."+имяРеквизита+" = &"+имяРеквизита+" ИНАЧЕ ИСТИНА КОНЕЦ ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоДокументов;
КонецФункции

Функция ПолучитьКоличествоЭлементовСправочникаПоОтбору(видСправочника, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(видСправочника, "видСправочника");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Спр.Ссылка) КАК КоличествоЭлементов
	|ИЗ
	|	Справочник."+видСправочника+" КАК Спр
	|ГДЕ
	|	Истина
	|";
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Спр."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоЭлементов;
КонецФункции

Функция ПолучитьКоличествоСтрокВДокументахПоОтбору(видДокумента, имяТабличнойЧасти, Дата1, дата2, структураОтбораШапки = Неопределено, структураОтбораТабличнойЧасти = Неопределено) Экспорт
		ПроверитьЗаполненность(видДокумента, "видДокумента");
		ПроверитьЗаполненность(Дата1, "Дата1");
		ПроверитьЗаполненность(Дата2, "Дата2");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(Доки.Ссылка) КАК КоличествоДокументов
	|ИЗ
	|	Документ."+видДокумента+"."+имяТабличнойЧасти+" КАК Доки
	|ГДЕ
	|	Доки.Ссылка.Дата МЕЖДУ &Дата1 И &Дата2
	|";
	Запрос.УстановитьПараметр("Дата1", Дата1);
	Запрос.УстановитьПараметр("Дата2", КонецДня(Дата2));
	
	Если ЗначениеЗаполнено(структураОтбораШапки) Тогда
		Для каждого ключЗначение Из структураОтбораШапки Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки.Ссылка."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	Если ЗначениеЗаполнено(структураОтбораТабличнойЧасти) Тогда
		Для каждого ключЗначение Из структураОтбораТабличнойЧасти Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоДокументов;
КонецФункции

Функция ПолучитьИтоговуюСуммуТабличнойЧастиДокументовПоОтбору(видДокумента, имяТабличнойЧасти, имяРеквизита, Дата1, дата2, структураОтбораШапки = Неопределено, структураОтбораТабличнойЧасти = Неопределено) Экспорт
		ПроверитьЗаполненность(видДокумента, "видДокумента");
		ПроверитьЗаполненность(Дата1, "Дата1");
		ПроверитьЗаполненность(Дата2, "Дата2");
	Запрос = Новый Запрос;
	текстТабличнаяЧасть = ?(НЕ ЗначениеЗаполнено(имяТабличнойЧасти), "", "."+имяТабличнойЧасти);
	Запрос.Текст = "ВЫБРАТЬ
	|	ЕСТЬNULL(СУММА(Доки."+имяРеквизита+"), 0) КАК Сумма
	|ИЗ
	|	Документ."+видДокумента+текстТабличнаяЧасть+" КАК Доки
	|ГДЕ
	|	Доки.Ссылка.Дата МЕЖДУ &Дата1 И &Дата2
	|";
	Запрос.УстановитьПараметр("Дата1", Дата1);
	Запрос.УстановитьПараметр("Дата2", КонецДня(Дата2));
	
	Если ЗначениеЗаполнено(структураОтбораШапки) Тогда
		Для каждого ключЗначение Из структураОтбораШапки Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки.Ссылка."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
		ПроверитьИстину(НЕ (имяТабличнойЧасти = "" И ЗначениеЗаполнено(структураОтбораТабличнойЧасти)), "табличная часть не должна быть указана");
	Если ЗначениеЗаполнено(структураОтбораТабличнойЧасти) Тогда
		Для каждого ключЗначение Из структураОтбораТабличнойЧасти Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.Сумма;
КонецФункции

Функция ПолучитьИтоговуюСуммуДокументовПоОтбору(видДокумента, имяРеквизита, Дата1, дата2, структураОтбораШапки = Неопределено, структураОтбораТабличнойЧасти = Неопределено) Экспорт
	Возврат ПолучитьИтоговуюСуммуТабличнойЧастиДокументовПоОтбору(видДокумента, "", имяРеквизита, Дата1, дата2, структураОтбораШапки, структураОтбораТабличнойЧасти);
КонецФункции

Функция ПолучитьКоличествоЭлементовМетаданногоПоОтбору(типМетаданного, видМетаданного, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(типМетаданного, "типМетаданного");
		ПроверитьЗаполненность(видМетаданного, "видМетаданного");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Таб.Ссылка) КАК КоличествоЭлементов
	|ИЗ
	|	"+типМетаданного+"."+видМетаданного+" КАК Таб
	|ГДЕ
	|	Истина
	|";
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Таб."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоЭлементов;
КонецФункции

Функция ПолучитьКоличествоБизнесПроцессовПоОтбору(видМетаданного, структураОтбора = Неопределено) Экспорт
	Возврат ПолучитьКоличествоЭлементовМетаданногоПоОтбору("БизнесПроцесс", видМетаданного, структураОтбора);
КонецФункции

Функция ПолучитьКоличествоЗадачПоОтбору(видМетаданного, структураОтбора = Неопределено) Экспорт
	Возврат ПолучитьКоличествоЭлементовМетаданногоПоОтбору("Задача", видМетаданного, структураОтбора);
КонецФункции

Функция ПолучитьКоличествоЭлементовРегистраПоОтбору(типМетаданного, видМетаданного, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(типМетаданного, "типМетаданного");
		ПроверитьЗаполненность(видМетаданного, "видМетаданного");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК КоличествоЭлементов
	|ИЗ
	|	"+типМетаданного+"."+видМетаданного+" КАК Таб
	|ГДЕ
	|	Истина
	|";
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Таб."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоЭлементов;
КонецФункции

Функция ПолучитьЭлементыМетаданногоПоОтбору(типМетаданного, видМетаданного, Количество=1, структураОтбора = Неопределено) Экспорт
	ПроверитьЗаполненность(типМетаданного, "типМетаданного");
	ПроверитьЗаполненность(видМетаданного, "видМетаданного");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ "+Количество+"
	|	*
	|ИЗ
	|	"+типМетаданного+"."+видМетаданного+" КАК Таб
	|ГДЕ
	|	Истина
	|";
		
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Таб."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	ТЗ = РезультатЗапроса.Выгрузить();
	
	Возврат ТЗ;
КонецФункции

//}

//{ МЕТОДЫ ДЛЯ ВЫПОЛНЕНИЯ ТЕСТОВ

// Выполняет отдельный тест.
// 
Функция ВыполнитьТест(СтрокаДереваТестов, СписокОшибокРез) Экспорт
	Перем Тест; // специально локальная переменная для исключения циклических ссылок
	
	Тест = Неопределено;
	
	мСписокОшибок = СписокОшибокРез;
	
	ИмяТестовогоСлучая	= СтрокаДереваТестов.ИмяТестовогоСлучая; //Имя;
	
	ТекущаяДата = ТекущаяДата();
	ПолныйПуть = СтрокаДереваТестов.ПолныйПуть;
	
	Если РегистрацияПрохожденияТестовВЖР Тогда
		ЗарегистрироватьНачалоПрохожденияТеста(ИмяТестовогоСлучая, ПолныйПуть);
	КонецЕсли;
	
	Попытка
		Если СтрокаДереваТестов.ЭтоВнутренняяОбработка Тогда
			Тест = СоздатьОбъектОбработкиКонфигурации(ПолныйПуть);
		Иначе
			Тест = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(ПолныйПуть); //ВнешниеОбработки.Создать(СтрокаДереваТестов.ПолныйПуть, Ложь);	// безопасный режим выключен
		КонецЕсли;
		массивТестов = ПолучитьТестовыеСлучаи(Тест, ПолныйПуть); // возможно, что тест сохранит у себя ссылку на браузер
		ПроверитьЗаполненность(массивТестов, "Не удалось получить тестовые случаи");
	Исключение
		
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ;
		СостояниеВыполнения = ВывестиОшибкуВыполненияТеста(ИмяТестовогоСлучая, текстОшибки, СтрокаДереваТестов, ОписаниеОшибки(), ИнформацияОбОшибке());
		
		Тест = Неопределено; // обязательно удаляем, для исключения циклических ссылок
		
		Возврат СостояниеВыполнения;
	КонецПопытки;
	
	СостояниеВыполнения = мЗначенияСостоянияТестов.НеВыполнялся;
	
	параметрыТеста = СтрокаДереваТестов.ПараметрыТеста;
	естьПараметры = СтрокаДереваТестов.ЕстьПараметрыТеста;
	
	естьТранзакция = Ложь;
	Если естьПараметры Тогда
		лПараметрыТеста = ?(ТипЗнч(параметрыТеста) = Тип("Структура"), параметрыТеста, параметрыТеста[0].Значение);
		Если лПараметрыТеста.Свойство("Транзакция", естьТранзакция) Тогда
			естьТранзакция = ТипЗнч(естьТранзакция) = Тип("Булево") и естьТранзакция;
		Иначе
			естьТранзакция = Ложь;
		КонецЕсли;

		Если естьТранзакция Тогда
			НачатьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
		//TODO Если первый раз запуск setup оказался неуспешным, то при повторном прогоне без перезагрузки
		// не выполнять, также не выполнять для следующих тестовых случаев.
	лСостояниеВыполнения = ВыполнитьПроцедуруТестовогоСлучая(Тест, "ПередЗапускомТеста", ИмяТестовогоСлучая, СтрокаДереваТестов);
	Если лСостояниеВыполнения <> Неопределено Тогда
		СостояниеВыполнения = лСостояниеВыполнения;
	КонецЕсли;
	Если СостояниеВыполнения = мЗначенияСостоянияТестов.Сломался Тогда
		Возврат мЗначенияСостоянияТестов.Сломался;
	КонецЕсли;
		
	переданПараметрТеста = Ложь;
	параметрТеста = "";
	
	Если естьПараметры Тогда
		лПараметрыТеста = ?(ТипЗнч(параметрыТеста) = Тип("Структура"), параметрыТеста, параметрыТеста[0].Значение);
		переданПараметрТеста = лПараметрыТеста.Свойство("Параметр", параметрТеста);
		
		Если переданПараметрТеста Тогда
			строкаПараметров = "параметрТеста";	
		КонецЕсли;
	КонецЕсли;
	
	ОповеститьОСобытии("TestStart", СтрокаДереваТестов);
	
	Если СтрокаДереваТестов.ВызыватьИсключение = Истина Тогда
		ВызватьИсключение "ПередЗапускомТеста " + ИмяТестовогоСлучая + " файл:"+ПолныйПуть;
	КонецЕсли;


	Попытка
		
		Выполнить("Тест." + ИмяТестовогоСлучая + "(" + строкаПараметров + ");");
		
		СостояниеВыполнения = мЗначенияСостоянияТестов.Прошел;
		
		ОповеститьОСобытии("TestPassed", СтрокаДереваТестов);
		
	Исключение
		
		// Issue https://github.com/xDrivenDevelopment/xUnitFor1C/issues/378
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
 
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		Если ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, ИмяТестовогоСлучая) Тогда
			СостояниеВыполнения = мЗначенияСостоянияТестов.НеРеализован;
			
			ОповеститьОСобытии("TestNotImplemented", СтрокаДереваТестов);
					
		Иначе
			
			СостояниеВыполнения = ВывестиОшибкуВыполненияТеста(ИмяТестовогоСлучая, текстОшибки, СтрокаДереваТестов, ОписаниеОшибки(), ИнформацияОбОшибке());

		КонецЕсли;
				
	КонецПопытки;	
	
	лСостояниеВыполнения = ВыполнитьПроцедуруТестовогоСлучая(Тест, "ПослеЗапускаТеста", ИмяТестовогоСлучая, СтрокаДереваТестов);
	Если лСостояниеВыполнения <> Неопределено Тогда
		СостояниеВыполнения = ЗапомнитьСамоеХудшееСостояние(СостояниеВыполнения, лСостояниеВыполнения); //СостояниеВыполнения = лСостояниеВыполнения;
	КонецЕсли;
	
	Если естьТранзакция Тогда
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	СтрокаДереваТестов.ВремяВыполнения = Число(ТекущаяДата()-ТекущаяДата);
	Тест = Неопределено; // для исключения циклических ссылок
		
	Возврат СостояниеВыполнения;
	
КонецФункции

Функция ВыполнитьПроцедуруТестовогоСлучая(Тест, ИмяПроцедуры, ИмяТестовогоСлучая, СтрокаДереваТестов)
	СостояниеВыполнения = Неопределено;
	
	Попытка
		Выполнить("Тест." + ИмяПроцедуры + "();");
	Исключение
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ;
		
		Если НЕ ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, ИмяПроцедуры) Тогда
			СостояниеВыполнения = ВывестиОшибкуВыполненияТеста(ИмяТестовогоСлучая, текстОшибки, СтрокаДереваТестов, ОписаниеОшибки(), ИнформацияОбОшибке());
		КонецЕсли;
	КонецПопытки;

	Возврат СостояниеВыполнения;

КонецФункции

Функция ВывестиОшибкуВыполненияТеста(ИмяТестовогоСлучая, текстОшибки, СтрокаДереваТестов, СообщениеОбОшибке, ИнфоОшибки)

	СостояниеВыполнения = мЗначенияСостоянияТестов.Сломался;
	
	СтруктураОшибки = Новый Структура();
	
	ЭтоСтрокаДереваУФ = Ложь;
	РодительскаяСтрока = РодительскаяСтрока(СтрокаДереваТестов, ЭтоСтрокаДереваУФ);
	СтруктураОшибки.Вставить("ИмяТестовогоНабора", РодительскаяСтрока.Имя);
	
	стИнфоОшибки = Новый Структура("ИмяМодуля,ИсходнаяСтрока,НомерСтроки,Описание"); //,Причина");
	ЗаполнитьЗначенияСвойств(стИнфоОшибки, ИнфоОшибки);
	стИнфоОшибки.Вставить("Причина",  Неопределено);
	
	стИнфоОшибкиЦикл = стИнфоОшибки;
	ИнфоОшибки = ИнфоОшибки.Причина;
	Пока ИнфоОшибки <> Неопределено Цикл
		стИнфоОшибкиЦикл.Причина = Новый Структура("ИмяМодуля,ИсходнаяСтрока,НомерСтроки,Описание");
		стИнфоОшибкиЦикл = стИнфоОшибкиЦикл.Причина;
		ЗаполнитьЗначенияСвойств(стИнфоОшибкиЦикл, ИнфоОшибки);
		стИнфоОшибкиЦикл.Вставить("Причина",  Неопределено);

		ИнфоОшибки = ИнфоОшибки.Причина;
	КонецЦикла;
	
	ИмяТестовогоСлучаяДляОписанияОшибки = ?(СтрокаДереваТестов.Имя <> ИмяТестовогоСлучая, СтрокаДереваТестов.Имя, ИмяТестовогоСлучая);
	
	СтруктураОшибки.Вставить("ИмяТестовогоСлучая", ИмяТестовогоСлучаяДляОписанияОшибки);
	СтруктураОшибки.Вставить("Описание",              текстОшибки);
	СтруктураОшибки.Вставить("СообщениеОбОшибке",     СообщениеОбОшибке);
	СтруктураОшибки.Вставить("ИнфоОшибки",            стИнфоОшибки);
	СтруктураОшибки.Вставить("ЕстьПараметрыТеста",    СтрокаДереваТестов.ЕстьПараметрыТеста);
	СтруктураОшибки.Вставить("ПараметрыТеста",        СтрокаДереваТестов.ПараметрыТеста);
	СтруктураОшибки.Вставить("ПолныйПуть",            СтрокаДереваТестов.ПолныйПуть);
	СтруктураОшибки.Вставить("УИДСтрокиДерева",       СтрокаДереваТестов._guid);
	
	Если ЭтоСтрокаДереваУФ Тогда
		СтруктураОшибки.Вставить("Идентификатор",       СтрокаДереваТестов.ПолучитьИдентификатор());
	Иначе
		СтруктураОшибки.Вставить("Идентификатор",       Неопределено);
	КонецЕсли;
	
	НужныйТекстОшибки = ВывестиОшибку(СтруктураОшибки);
	
	мСписокОшибок.Добавить(СтруктураОшибки);
	
	ЗарегистрироватьОшибкуТеста(НужныйТекстОшибки, ИмяТестовогоСлучаяДляОписанияОшибки, СтрокаДереваТестов.ПолныйПуть);
	
	Попытка
		ОповеститьОСобытии("TestFailed", СтрокаДереваТестов);
	Исключение
	КонецПопытки;

	Возврат СостояниеВыполнения;

КонецФункции

// Выполняет рекурсивно все тесты строки дерева тестов для
// строк, являющихся группами (обработками или каталогами).
// 
Функция _ВыполнитьТесты(СтрокиДереваТестов) //Экспорт
	
	СостояниеРезультат = мЗначенияСостоянияТестов.НеВыполнялся;
	
	Для каждого СтрокаДереваТестов из СтрокиДереваТестов Цикл
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли 

		Если СтрокаДереваТестов.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
			
			мВсегоТестов = мВсегоТестов + 1;
			НовоеСостояние = ВыполнитьТест(СтрокаДереваТестов, мСписокОшибок);
			
		Иначе
			
			НовоеСостояние = _ВыполнитьТесты(СтрокаДереваТестов.Строки);
			
		КонецЕсли;
		
		СтрокаДереваТестов.Состояние = НовоеСостояние;
		
		ЗапомнитьСамоеХудшееСостояние(СостояниеРезультат, НовоеСостояние);
		
		ИзменитьСостояниеВыполненияРодителей(СтрокаДереваТестов);
		
	КонецЦикла;
	
	Возврат СостояниеРезультат;
	
КонецФункции

// Выполняет рекурсивно все тесты строки дерева тестов для
// строк, являющихся группами (обработками или каталогами).
// 
Функция ВыполнитьТесты(СтрокиДереваТестов) Экспорт
	ПередВыполнениемТестов();
	
	датаНачалаТестирования = ТекущаяДата();
	
	результат = _ВыполнитьТесты(СтрокиДереваТестов);
	
	//ПолучитьОтчетТестирования(датаНачалаТестирования, "xml");
	
	Возврат результат;
КонецФункции

Процедура ПередВыполнениемТестов() Экспорт
	мСписокОшибок = Новый СписокЗначений;
	мВсегоТестов = 0;
КонецПроцедуры

//}

//{ МЕТОДЫ ЗАГРУЗКИ ТЕСТОВ

Функция ЗагрузитьТестыКонфигурации(Путь) Экспорт
	Если ЗначениеЗаполнено(Путь) Тогда
		мКоличествоТестовыхСлучаев = 0;
		ОбъектМетаданных = ПолучитьОбъектМетаданныхПоПути(Путь);
		Если ОбъектМетаданных<>Неопределено Тогда
			Если Лев(ОбъектМетаданных.ПолноеИмя(),11) = "Подсистема." Тогда
				ЗагрузитьТестыПодсистемы(ДеревоТестов,ОбъектМетаданных);
				ОчиститьДерево(ДеревоТестов);
			Иначе
				ЗагрузитьВстроенныйТестовыйСлучай(ДеревоТестов,ОбъектМетаданных);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецФункции

// Загружает тесты в дерево тестов из подсистемы конфигурации.
//
Функция ЗагрузитьТестыПодсистемы(СтрокаДерева,Подсистема) Экспорт
	
	СтрокаТеста = ДобавитьСтрокуДереваТестов(СтрокаДерева, Подсистема.Имя, Подсистема.Имя, Подсистема.ПолноеИмя(), 
			Истина, мЗначенияТиповСтроки.Подсистема, Неопределено);
	
	Для каждого ПодчиненнаяПодсистема из Подсистема.Подсистемы цикл
		ЗагрузитьТестыПодсистемы(СтрокаТеста,ПодчиненнаяПодсистема);
	КонецЦикла;	
	
	Для каждого Обработка из Подсистема.Состав цикл
		ЗагрузитьВстроенныйТестовыйСлучай(СтрокаТеста,Обработка);
	КонецЦикла;
	
КонецФункции

// Загружает тестовый случай (обработку) 
//
Функция ЗагрузитьВстроенныйТестовыйСлучай(СтрокаДерева,Обработка)
	ДанныеОбработки = новый Структура("ПолноеИмя,ИмяБезРасширения");
	//Если Лев(Обработка.Имя,5) = "Тест_" Тогда
		ДанныеОбработки.ПолноеИмя = Обработка.Имя;
		ДанныеОбработки.ИмяБезРасширения = Обработка.Имя;
		ДобавитьТест(СтрокаДерева,ДанныеОбработки,,,,Истина);
	//КонецЕсли;
КонецФункции

// Устанавливает всем родителям по иерархии признак наличия тестов в иерархии
//
Процедура ПометитьРодителя(ТекСтрока) Экспорт
	СтрокаРодитель = РодительскаяСтрока(ТекСтрока);

	Если СтрокаРодитель <> неопределено Тогда
		СтрокаРодитель.ИмеетТесты = Истина;
		ПометитьРодителя(СтрокаРодитель);
	КонецЕсли;
КонецПроцедуры

// Убирает из дерева все строки, в иерархии которых нет тестов
//
Процедура ОчиститьДерево(СтрокаДерева) Экспорт
	Строки = ПодчиненныеСтроки(СтрокаДерева);
	сч = Строки.Количество()-1;
	Пока сч>=0 цикл
		Строка = Строки[сч];
		Если Не Строка.ИмеетТесты Тогда
			Строки.удалить(сч);
		Иначе
			ОчиститьДерево(Строка);
		КонецЕсли;
		сч = сч - 1;
	КонецЦикла;
КонецПроцедуры

// Загружает тесты в дерево тестов из каталога.
// 
Функция ЗагрузитьВсеТесты(ПутьККаталогу) Экспорт
	
	мКоличествоТестовыхСлучаев = 0;
	
	ДеревоТестов.Строки.Очистить();
	
	ОбъектФайл = Новый Файл(ПутьККаталогу);
	Если ОбъектФайл.Существует() Тогда
		
		Возврат ЗагрузитьТесты(ДеревоТестов, ОбъектФайл);
		
	КонецЕсли;	
	
	ВывестиОшибку(НСтр("en = 'File or directory does not exist ""'; ru = 'Файл или каталог не существует ""'") +
                           ОбъектФайл.ПолноеИмя + """");
	Возврат Ложь;	
КонецФункции

// Выполняет рекурсивную загрузку тестов и тестовых случаев
// из обработки или каталога с обработками для тестирования.
// 
Функция ЗагрузитьТесты(РодительскаяСтрока, ОбъектФайл)
	
	Если ОбъектФайл.ЭтоКаталог() Тогда
		Если ОбъектФайл.ПолучитьНевидимость() и ОбъектФайл.Имя = ".git" Тогда
			Возврат Истина;
		КонецЕсли;
			
		СтрокаКаталога = ДобавитьСтрокуДереваТестов(РодительскаяСтрока, ОбъектФайл.Имя, ОбъектФайл.Имя, ОбъектФайл.ПолноеИмя, 
			Ложь, мЗначенияТиповСтроки.КаталогТестов, Неопределено);
		
		НайденныеФайлы = НайтиФайлы(ОбъектФайл.ПолноеИмя, "*", Ложь);
		Для каждого Файл из НайденныеФайлы Цикл
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			#КонецЕсли 
			
			Если Файл.ЭтоКаталог() Тогда
				
				ЗагрузитьТесты(СтрокаКаталога, Файл);
				 
			ИначеЕсли НРег(Файл.Расширение) = ".epf" Тогда //И НРег(Лев(Файл.Имя, 4)) = "тест" Тогда
				
				ДобавитьТест(СтрокаКаталога, Файл);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтрокаКаталога.Строки.Количество() = 0 Тогда
			РодительскаяСтрока.Строки.Удалить(СтрокаКаталога);
		КонецЕсли;
		
	Иначе
		
		Если РодительскаяСтрока = ДеревоТестов ИЛИ РодительскаяСтрока.ТипСтроки = мЗначенияТиповСтроки.КаталогТестов Тогда
			ДобавитьТест(РодительскаяСтрока, ОбъектФайл);		
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат Истина;
КонецФункции

// Добавляет тестовую обработку (тест) в дерево тестов.
// 
Процедура ДобавитьТест(РодительскаяСтрока, ФайлТеста, ТестовыйСлучайОбъектМетаданныхИмя = Неопределено, ДобавлятьСтрокуТестОбъект = Истина, НуженСписокЗначений = Ложь, 
		ЭтоВнутренняяОбработка = Ложь) Экспорт
		
	Перем ТестОбъект; // специально локальная переменная для исключения циклических ссылок
	
	ТестОбъект = Неопределено;
	
	ПолноеИмяТестовогоСлучая = ФайлТеста.ПолноеИмя;
	ПутьФайлаТеста = ФайлТеста.ПолноеИмя;
	Попытка
		Если ЭтоВнутренняяОбработка Тогда
			ТестОбъект = СоздатьОбъектОбработкиКонфигурации(ФайлТеста.ИмяБезРасширения); //Обработки[ИмяОбработки].Создать();
        ИначеЕсли ТестовыйСлучайОбъектМетаданныхИмя = Неопределено Тогда
            ТестОбъект = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(ПолноеИмяТестовогоСлучая); //ВнешниеОбработки.Создать(ПолноеИмяТестовогоСлучая, Ложь);	// безопасный режим выключен
        Иначе
            ТестОбъект = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(ТестовыйСлучайОбъектМетаданныхИмя); //ВнешниеОбработки.Создать(ТестовыйСлучайОбъектМетаданныхИмя, Ложь);	// безопасный режим выключен
			ПутьФайлаТеста = ТестовыйСлучайОбъектМетаданныхИмя;
        КонецЕсли;
	Исключение
		ВывестиОшибку("Тест не загружен: " + ПолноеИмяТестовогоСлучая + "
		|	Ошибка: " + ОписаниеОшибки());
		Возврат;
	КонецПопытки;
	
	МассивТестовыхСлучаев = ПолучитьТестовыеСлучаи(ТестОбъект, ПолноеИмяТестовогоСлучая);
	
	Если МассивТестовыхСлучаев <> Неопределено Тогда
		Если ДобавлятьСтрокуТестОбъект Тогда
			СтрокаТеста = ДобавитьСтрокуДереваТестов(РодительскаяСтрока, ФайлТеста.ИмяБезРасширения, ФайлТеста.ИмяБезРасширения, ПолноеИмяТестовогоСлучая, 
			ЭтоВнутренняяОбработка, мЗначенияТиповСтроки.ТестовыйСлучай, Неопределено,,, НуженСписокЗначений);
		Иначе
			СтрокаТеста = РодительскаяСтрока;
		КонецЕсли;
		
		Для каждого ТестовыйСлучай из МассивТестовыхСлучаев Цикл
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			#КонецЕсли 
			
			Если ТипЗнч(ТестовыйСлучай) = Тип("Строка") Тогда
				имяТестовогоСлучая = ТестовыйСлучай;
				параметрыТеста = Неопределено;
				ПредставлениеТеста = имяТестовогоСлучая;
            Иначе
                имяТестовогоСлучая = ТестовыйСлучай.ИмяТеста;
                параметрыТеста = ТестовыйСлучай;
				Если НЕ ТестовыйСлучай.Свойство("ПредставлениеТеста", ПредставлениеТеста) или не ЗначениеЗаполнено(ПредставлениеТеста) Тогда
					ПредставлениеТеста = имяТестовогоСлучая;
				КонецЕсли;
			КонецЕсли;
			
			ДобавитьСтрокуДереваТестов(СтрокаТеста, ПредставлениеТеста, имяТестовогоСлучая, ПутьФайлаТеста, ЭтоВнутренняяОбработка,
				мЗначенияТиповСтроки.ТестовыйМетод, параметрыТеста,, мЗначениеМодульИлиФорма.Модуль, НуженСписокЗначений);
			
			мКоличествоТестовыхСлучаев = мКоличествоТестовыхСлучаев + 1;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ТестОбъект = Неопределено;
КонецПроцедуры 

// Добавляет в дерево тестов новую строку.
// 
Функция ДобавитьСтрокуДереваТестов(РодительскаяСтрока, ПредставлениеТестовогоСлучая, ИмяТестовогоСлучая, ПутьКФайлу, ЭтоВнутренняяОбработка, ТипСтроки = 0, ПараметрыТеста = Неопределено, Состояние=0, МодульИлиФорма = 0, НуженСписокЗначений = Ложь)

	НоваяСтрока = ПодчиненныеСтроки(РодительскаяСтрока).Добавить();
	
	НоваяСтрока.Имя = ПредставлениеТестовогоСлучая;
	НоваяСтрока.ПолныйПуть = ПутьКФайлу;
	//НоваяСтрока.ПредставлениеПути = СтрЗаменить(ПутьКФайлу, НоваяСтрока.ПолучитьРодителя().ПолныйПуть, "...");
	НоваяСтрока.ТипСтроки = ТипСтроки;
	НоваяСтрока.Состояние = Состояние;
	НоваяСтрока._guid = Строка(Новый УникальныйИдентификатор());
    НоваяСтрока.МодульИлиФорма = МодульИлиФорма;
	
	НоваяСтрока.ЕстьПараметрыТеста = Ложь;
	НоваяСтрока.ИмяТестовогоСлучая = ИмяТестовогоСлучая;
	ЗаданоСпециальноеПредставлениеТеста = НоваяСтрока.Имя <> НоваяСтрока.ИмяТестовогоСлучая;
	
	НоваяСтрока.ЭтоВнутренняяОбработка = ЭтоВнутренняяОбработка;
	Если ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай Или ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
		НоваяСтрока.ИмеетТесты = Истина;
		ПометитьРодителя(НоваяСтрока);
	Иначе
		НоваяСтрока.ИмеетТесты = Ложь;
	КонецЕсли;
	
    Если НуженСписокЗначений И ПараметрыТеста <> Неопределено Тогда
        СЗ = Новый СписокЗначений();
        СЗ.Добавить(ПараметрыТеста);
        НоваяСтрока.ПараметрыТеста = СЗ;
		НоваяСтрока.ЕстьПараметрыТеста = Истина;
		
		Если Не ЗаданоСпециальноеПредставлениеТеста Тогда
			описаниеПараметра = "<пусто>";
			Если ПараметрыТеста.Свойство("Параметр") Тогда
				описаниеПараметра = "" + ПараметрыТеста.Параметр;
			КонецЕсли;
			
			НоваяСтрока.Имя = НоваяСтрока.Имя + " ( " + описаниеПараметра + " )";
		КонецЕсли;
		
    Иначе
        НоваяСтрока.ПараметрыТеста = ПараметрыТеста;
		Если ПараметрыТеста <> Неопределено Тогда
			НоваяСтрока.ЕстьПараметрыТеста = Истина;
			
			Если Не ЗаданоСпециальноеПредставлениеТеста Тогда
				описаниеПараметра = "<пусто>";
				Если ПараметрыТеста.Свойство("Параметр") Тогда
					описаниеПараметра = "" + ПараметрыТеста.Параметр;
				КонецЕсли;
				
				НоваяСтрока.Имя = НоваяСтрока.Имя + " ( " + описаниеПараметра + " )";
			КонецЕсли;
		КонецЕсли;
		
    КонецЕсли;
	
	ОповеститьОСобытии("TestLoaded", НоваяСтрока);
	
	Возврат НоваяСтрока;
	
КонецФункции

//}
	
// получает мИнформатор. Возвращает Неопределено, если мИнформатор не удалось загрузить
Функция ПолучитьИнформатор() Экспорт
	
#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
	ВызватьИсключение "Информатор пока можно использовать только в толстом клиенте обычного приложения!";
#КонецЕсли
	
	Если мИнформатор = Неопределено И мПытаемсяСоздатьИнформатор Тогда
		СистемнаяИнформация = Новый СистемнаяИнформация;
		используемПлатформу8_3 = Лев(СистемнаяИнформация.ВерсияПриложения, 3) = "8.3";
		Если используемПлатформу8_3 Тогда
			мПытаемсяСоздатьИнформатор = Ложь;
			Возврат Неопределено;
		КонецЕсли;
		
		
		Если НЕ ЭтоВнешняяОбработка() Тогда
			Попытка
				мИнформатор = Неопределено;
				Выполнить("мИнформатор = Обработки.xddInformator.Создать();");
			Исключение
				ВывестиОшибку("Класс Информатор не удалось создать <Обработки.xddInformator>");
				
				мИнформатор = Неопределено;
				мПытаемсяСоздатьИнформатор = Ложь;
				Возврат Неопределено;
			КонецПопытки;
		Иначе
			НайденноеИмяФайла = Неопределено;
			Выполнить("НайденноеИмяФайла = ЭтотОбъект.ИспользуемоеИмяФайла;");
			файл = Новый Файл(НайденноеИмяФайла);
    			
			путьИнформатора = файл.Путь + "xddInformator.epf";
			файл = Новый Файл(путьИнформатора);
			
			Если НЕ файл.Существует() Тогда
				ВывестиОшибку("Класс Информатор не найден <"+путьИнформатора+">");
				Возврат Неопределено;
			КонецЕсли;
			
			Попытка
				мИнформатор = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(путьИнформатора); //ВнешниеОбработки.Создать(путьИнформатора, Ложь);	// безопасный режим выключен
			Исключение
				ВывестиОшибку("Класс Информатор не удалось создать <"+путьИнформатора+">");
				
				мИнформатор = Неопределено;
				мПытаемсяСоздатьИнформатор = Ложь;
				Возврат Неопределено;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат мИнформатор;
КонецФункции

// Получает с помощью Информатора массив тестовых экспортных методов, начинающихся с Тест
// может вызываться из теста из его метода ПолучитьСписокТестов(ЮнитТестирование)
Функция ДобавитьПростыеТестыИзОбъекта(массивТестов, ТестовыйОбъект) Экспорт
	Если мИнформатор = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		ТаблицаМетодов = мИнформатор.ПолучитьТаблицуМетодов(ТестовыйОбъект);

		Для каждого СтрокаТаблицыМетодов из ТаблицаМетодов Цикл
			наименованиеТеста = СтрокаТаблицыМетодов.Наименование;
			Если НРег(Лев(наименованиеТеста, 4)) = "тест" 
				И СтрокаТаблицыМетодов.КоличествоПараметров = 0 Тогда
				
				Если массивТестов.Найти(наименованиеТеста) = Неопределено Тогда
					массивТестов.Добавить(наименованиеТеста);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		ВывестиОшибку("Ошибка получения списка тестовых случаев: " + ОписаниеОшибки());		
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

// Возвращает массив тестовых случаев обработки для тестирования.
Функция ПолучитьТестовыеСлучаи(ТестОбъект, ПолноеИмяОбъекта)

	Попытка
        
		#Если ТолстыйКлиентОбычноеПриложение Тогда
					//#Если Клиент Тогда
			получаемСписокТестовИзТестОбъекта = мИнформатор = Неопределено 
				или мИнформатор.МетодСуществует(ТестОбъект, "ПолучитьСписокТестов"); // после вызова Информатора появляются циклические ссылки
			Если НЕ получаемСписокТестовИзТестОбъекта Тогда
				Возврат Неопределено;
			КонецЕсли;
		
        #Иначе
			получаемСписокТестовИзТестОбъекта = Истина;
        #КонецЕсли    
		
		Если получаемСписокТестовИзТестОбъекта Тогда
			МассивТестовыхСлучаев = ТестОбъект.ПолучитьСписокТестов(ЭтотОбъект);
		КонецЕсли;
		
	Исключение
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ;
		
		// TODO если не использовать переменную ниже, а поставить вызов метода в условие, то будет глюк - внутрь условия не попадаем !
		ЕстьОшибка_МетодОбъектаНеОбнаружен = ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, "ПолучитьСписокТестов");
		Если НЕ ЕстьОшибка_МетодОбъектаНеОбнаружен Тогда
		
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Ошибка получения списка тестовых случаев: " + ОписаниеОшибки());
			
			ТестОбъект = Неопределено;
		КонецЕсли;
		
		Возврат Неопределено;			
				
	КонецПопытки;

		Если ТипЗнч(МассивТестовыхСлучаев) <> Тип("Массив") Тогда
			
				//Если выводитьОшибку Тогда
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Ошибка получения списка тестовых случаев: вместо массива имен тестовых случаев получен объект <" + Строка(ТипЗнч(МассивТестовыхСлучаев)) + ">");
				//КонецЕсли;
			ТестОбъект = Неопределено;
			Возврат Неопределено;			
			
		КонецЕсли;
		
		Если НЕ ПроверитьМассивТестовыхСлучаев(МассивТестовыхСлучаев, ТестОбъект, ПолноеИмяОбъекта) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат МассивТестовыхСлучаев;
		
	Возврат Неопределено;
		
КонецФункции

Функция ПроверитьМассивТестовыхСлучаев(МассивТестовыхСлучаев, ТестОбъект, ПолноеИмяОбъекта)
	Для каждого данныеТеста из МассивТестовыхСлучаев Цикл
		Если ТипЗнч(данныеТеста) = Тип("Строка") Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(данныеТеста) <> Тип("Структура") Тогда
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Ошибка получения структуры описания тестового случая: " + ОписаниеОшибки());
			Возврат Ложь;
		КонецЕсли;
		Если НЕ данныеТеста.Свойство("ИмяТеста") Тогда
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Не задано имя теста в структуре описания тестового случая: " + ОписаниеОшибки());
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Возвращает количество подчиненных тестовых случаев для заданной строки дерева тестов.
// 
Функция ПолучитьКоличествоТестовыхСлучаев(СтрокаДереваТестов) Экспорт
	
	Если СтрокаДереваТестов.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
		Возврат 1;		
	КонецЕсли;	
	
	КоличествоТестовыхСлучаев = 0;
	Для каждого ПодчиненнаяСтрока из СтрокаДереваТестов.Строки Цикл
		КоличествоТестовыхСлучаев = КоличествоТестовыхСлучаев + ПолучитьКоличествоТестовыхСлучаев(ПодчиненнаяСтрока);
	КонецЦикла;
	
	Возврат КоличествоТестовыхСлучаев;
	
КонецФункции

Процедура ЗаполнитьРезультатТестовогоСлучая(ЗаписьXML, СтрокаТестов, КэшОшибок)
	
	#Если _ Тогда
	ЗаписьXML = Новый ЗаписьXML;
	#КонецЕсли
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
	ЗаписьXML.ЗаписатьАтрибут("classname", СтрокаТестов.Родитель.ИмяТестовогоСлучая);
	ЗаписьXML.ЗаписатьАтрибут("name", СтрокаТестов.Имя);
	ЗаписьXML.ЗаписатьАтрибут("time", XMLСтрока(СтрокаТестов.ВремяВыполнения));
	
	КлючСоответствия	= СтрокаТестов._guid;
	СтруктураОшибки		= КэшОшибок.Получить(КлючСоответствия);
	
	Если СтруктураОшибки <> Неопределено Тогда
		ЗаписьXML.ЗаписатьАтрибут("status", "failure");
		ЗаписьXML.ЗаписатьНачалоЭлемента("failure");

		СтрокаОписание = СтруктураОшибки.Описание;
		Поз = НайтиНедопустимыеСимволыXML(СтрокаОписание);
		Если Поз <> 0 Тогда
			Поз = 1;
			КоличествоПовторов = СтрДлина(СтрокаОписание);
			
			Пока КоличествоПовторов > 0 Цикл
				Поз = НайтиНедопустимыеСимволыXML(СтрокаОписание, Поз);
				Если Поз = 0 Тогда
					Прервать;
				КонецЕсли; 
				КоличествоПовторов = КоличествоПовторов - 1;
				СтрокаОписание = Лев(СтрокаОписание, Поз-1) + Сред(СтрокаОписание, Поз+1);
			КонецЦикла; 
		КонецЕсли; 
		XMLОписание = XMLСтрока(СтрокаОписание); 
		ЗаписьXML.ЗаписатьАтрибут("message", XMLОписание);
		
		ЗаписьXML.ЗаписатьКонецЭлемента();
	Иначе
		ЗаписьXML.ЗаписатьАтрибут("status", "passed");
	КонецЕсли;
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры

Процедура ЗаполнитьРезультатТестовИерархически(ЗаписьXML, СтрокаТестов, КэшОшибок) 
	
	#Если _ Тогда
	ЗаписьXML = Новый ЗаписьXML;
	#КонецЕсли

	Если СтрокаТестов.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
		
		ЗаполнитьРезультатТестовогоСлучая(ЗаписьXML, СтрокаТестов, КэшОшибок);
		Возврат;
		
	КонецЕсли;
		
	ЗаписьXML.ЗаписатьНачалоЭлемента("testsuite");	
	ЗаписьXML.ЗаписатьАтрибут("name", СтрокаТестов.Имя);
	ЗаписьXML.ЗаписатьНачалоЭлемента("properties");
	
	Если СтрокаТестов.ЕстьПараметрыТеста Тогда
		ЗаписьXML.ЗаписатьНачалоЭлемента("property");
		ЗаписьXML.ЗаписатьАтрибут("ЕстьПараметрыТеста",XMLСтрока(СтрокаТестов.ЕстьПараметрыТеста));
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЕсли;
		
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Для каждого ЭлементСтроки из СтрокаТестов.Строки Цикл 
		
		Если ЭлементСтроки.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда 
			ЗаполнитьРезультатТестовогоСлучая(ЗаписьXML, ЭлементСтроки, КэшОшибок);
			Продолжить;
		Иначе 
			ЗаполнитьРезультатТестовИерархически(ЗаписьXML, ЭлементСтроки, КэшОшибок)
		КонецЕсли;
		
	КонецЦикла;
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры

Функция ВывестиОтчетТестированияВФорматеJunitXML(ДеревоТестов, датаНачалаТестирования, ВсегоТестов, СписокОшибок) Экспорт 
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	
	КоличествоОшибок = СписокОшибок.Количество();
	
	КэшОшибок = Новый Соответствие();
	Для каждого ЭлементСписка из СписокОшибок Цикл
		КлючСоответствия = ЭлементСписка.Значение["УИДСтрокиДерева"];
		КэшОшибок.Вставить(КлючСоответствия, ЭлементСписка.Значение);
	КонецЦикла;
	КэшОшибок = Новый ФиксированноеСоответствие(КэшОшибок);
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("testsuites");
	ЗаписьXML.ЗаписатьАтрибут("tests", XMLСтрока(ВсегоТестов));
	ЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока("1CUNIT")); //TODO: указывать путь к набору тестов. 
	ЗаписьXML.ЗаписатьАтрибут("time", XMLСтрока(Формат(ТекущаяДата() - датаНачалаТестирования, "ДФ=HH.mm.ss")));
	ЗаписьXML.ЗаписатьАтрибут("failures", XMLСтрока(КоличествоОшибок));
	
	Для каждого ЭлементСтроки из ДеревоТестов.Строки Цикл
		ЗаполнитьРезультатТестовИерархически(ЗаписьXML, ЭлементСтроки, КэшОшибок);
		
	КонецЦикла;
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Возврат ЗаписьXML.Закрыть();
	
	
КонецФункции

// Возвращаем Неопределено, если все тесты прошли
Функция ПолучитьОтчетТестирования(датаНачалаТестирования, ТипОтчета =  "mxl") Экспорт
	СписокОшибок = мСписокОшибок;
	ВсегоТестов = мВсегоТестов;
	
	Если ТипОтчета = "xml" Тогда
		Текст = ВывестиОтчетТестированияВФорматеJunitXML(ДеревоТестов, датаНачалаТестирования, мВсегоТестов, мСписокОшибок);
		ТабДокумент = Новый ТекстовыйДокумент;
		ТабДокумент.УстановитьТекст(Текст);
		Возврат ТабДокумент;
	КонецЕсли;
	
	КоличествоОшибок = СписокОшибок.Количество();
	Если КоличествоОшибок = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПрошлоВремени = ТекущаяДата() - датаНачалаТестирования;
	
	ТабДок = Новый ТабличныйДокумент;
	макет = ПолучитьМакет("ОтчетТестирования");

	Секция = макет.ПолучитьОбласть("Заголовок"); //"R1C1:R6C1");
	Секция.Параметры.ВсегоТестов = ВсегоТестов;
	Секция.Параметры.КоличествоОшибок = КоличествоОшибок;
	Секция.Параметры.ПрошлоВремени = ПрошлоВремени;
	Секция.Параметры.ПрошлоВремениСтрока = формат(Дата(1,1,1) + ПрошлоВремени, "ДЛФ=T");
	Секция.Параметры.ВремяВыполненияОдногоТеста = ?(ВсегоТестов = 0, "", Формат(ПрошлоВремени / ВсегоТестов * 1000, "ЧЦ=15; ЧДЦ=2"));
	ТабДок.Вывести(Секция);

	ТабДок.НачатьАвтогруппировкуСтрок();
	
	Для Каждого Ошибка Из СписокОшибок Цикл
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли 

		ВывестиОшибкуВМакет(ТабДок, макет, Ошибка.Значение);
	КонецЦикла;
	
	ТабДок.ЗакончитьАвтогруппировкуСтрок();
	
	ТабДок.ОтображатьСетку = Ложь;
	ТабДок.Защита = Ложь;
	ТабДок.ТолькоПросмотр = Ложь;
	ТабДок.ОтображатьЗаголовки = Ложь;
	
	Возврат ТабДок;
КонецФункции

Процедура ВывестиОшибкуВМакет(ТабДок, макет, _Ошибка)
	Секция = макет.ПолучитьОбласть("НаименованиеНабора");
	ЗаполнитьЗначенияСвойств(Секция.Параметры, _Ошибка);
	ТабДок.Вывести(Секция, 1);
	
	Секция = макет.ПолучитьОбласть("НаименованиеТеста");
	ЗаполнитьЗначенияСвойств(Секция.Параметры, _Ошибка);
	ТабДок.Вывести(Секция, 2);
	
	Если _Ошибка.ЕстьПараметрыТеста Тогда
		Секция = макет.ПолучитьОбласть("ПараметрыТеста");
		ЗаполнитьЗначенияСвойств(Секция.Параметры, _Ошибка);
		ТабДок.Вывести(Секция, 2);
	КонецЕсли;
	
	ИнфоОшибки = _Ошибка.ИнфоОшибки;
	Пока ИнфоОшибки <> Неопределено Цикл  // Артур TODO
		Секция = макет.ПолучитьОбласть("R1C1:R4C3");
		Секция.Область("R1C3").Текст = ИнфоОшибки.ИмяМодуля + ", строка № "+ИнфоОшибки.НомерСтроки;
		Секция.Область("R2C3").Текст = ИнфоОшибки.ИсходнаяСтрока;
		Секция.Область("R3C3").Текст = ИнфоОшибки.Описание;
		
		ТабДок.Вывести(Секция, 3);
		
		ИнфоОшибки = ИнфоОшибки.Причина;
	КонецЦикла;
	
КонецПроцедуры

//{ ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ОБЩЕГО НАЗНАЧЕНИЯ

Функция Различны(ТаблицаОжиданий, ТаблицаРезультатов, ТаблицаРазличий) Экспорт
	
	ТаблицаРазличий.Колонки.Очистить();
	
	лОписаниеТипаБулево = Новый ОписаниеТипов("Булево");
	лФлагНеУчитыватьРазноеКоличествоСтрок = Ложь; //лОписаниеТипаБулево.ПривестиЗначение( ПолучитьУсловие("Тест_ФлагНеУчитыватьРазноеКоличествоСтрок") );
	
	Если НЕ лФлагНеУчитыватьРазноеКоличествоСтрок И ТаблицаОжиданий.Количество()<>ТаблицаРезультатов.Количество() Тогда
		Возврат ОшибкиСравненияТаблиц.ВидОшибки_РазноеКоличествоСтрок;
	КонецЕсли;
	
	Если ТаблицаОжиданий.Количество() = 0 Тогда
		Возврат ОшибкиСравненияТаблиц.ВидОшибки_НетОшибок; //Пустые таблицы всегда одинаковы
	КонецЕсли;
	
	//Проверим структуру колонок
	ИменаКолонок2 = Новый СписокЗначений;
	Для К = 0 По ТаблицаРезультатов.Колонки.Количество()-1 Цикл
		ИменаКолонок2.Добавить(ТаблицаРезультатов.Колонки[К].Заголовок);
	КонецЦикла;
	
	Для К = 0 По ТаблицаОжиданий.Колонки.Количество()-1 Цикл
		ИмяКолонки = ТаблицаОжиданий.Колонки[К].Заголовок;
		Если ИменаКолонок2.НайтиПоЗначению(ИмяКолонки) = Неопределено Тогда
			ТекстОшибки = "В таблице результатов отсутствует колонка """+ИмяКолонки+"""";
			
			Возврат ОшибкиСравненияТаблиц.ВидОшибки_ВРезультатеКолонкиНеСовпадают;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СравнитьТаблицыЗначений(ТаблицаОжиданий,ТаблицаРезультатов,ТаблицаРазличий);
КонецФункции

Функция СравнитьТаблицыЗначений(Т1, Т2, ТабРазличий) //Экспорт
	
	//TODO При этом сравнении в структуре Т2 может оказаться больше колонок, чем в Т1,
	// так что для абсолютного точного сравнения эту процедуру нужно гонять дважды
	// (второй раз таблицы надо поменять местами).
	
	ТабРазличий.Колонки.Очистить();
	ТабРазличий.Колонки.Добавить("Строка",Новый ОписаниеТипов("Число"));
	ТабРазличий.Колонки.Добавить("Колонка",Новый ОписаниеТипов("Строка"));
	ТабРазличий.Колонки.Добавить("Ожидание");
	ТабРазличий.Колонки.Добавить("Результат");
	
	ФЛ = ОшибкиСравненияТаблиц.ВидОшибки_НетОшибок; //0;
	
	лНомерПоследнейСтроки_Т1 = Т1.Количество()-1;
	лНомерПоследнейКолонки_Т1 = Т1.Колонки.Количество()-1;
	
	С = -1;
	
	Для каждого лСтрокаТаблицыТ1 Из Т1 Цикл
		С = С + 1;
		лСтрокаТаблицыТ2 = Т2[С];
		
		Для ИИ = 0 по лНомерПоследнейКолонки_Т1 Цикл
			Значение1 = лСтрокаТаблицыТ1[ИИ]; //Значение1 = Т1[С][ИИ];
			Значение2 = лСтрокаТаблицыТ2[ИИ]; //Значение2 = Т2[С][ИИ];
						
			Если Значение1<>Значение2 Тогда
				
				//Пустые значения разных типов 1С-м не считаются равными :(
				Если (Не ЗначениеЗаполнено(Значение1)) И
					(Не ЗначениеЗаполнено(Значение2)) Тогда
					
					Продолжить;
				КонецЕсли;
				
				ИмяКолонки = Т1.Колонки[ИИ].Заголовок;
				
				Стр = ТабРазличий.Добавить();
				Стр.Строка = С+1;
				Стр.Колонка = ИмяКолонки;
				Стр.Ожидание = Значение1;
				Стр.Результат = Значение2;
				ФЛ = ОшибкиСравненияТаблиц.ВидОшибки_НеСовпадаютЗначенияВЯчейкеТаблицы; //3;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла; // по Т1  
	
	Возврат ФЛ;
КонецФункции

Функция ВывестиОшибку(Ошибка) Экспорт
	
	НужныйТекстОшибки = ПолучитьРазвернутыйТекстОшибки(Ошибка);
	
	ВывестиСообщение(НужныйТекстОшибки, СтатусСообщения.Важное);

	Возврат НужныйТекстОшибки;
КонецФункции

Функция ПолучитьРазвернутыйТекстОшибки(Ошибка)
	ТипОбъектаОшибка = ТипЗнч(Ошибка);
		
	Если ТипОбъектаОшибка = Тип("Структура") Тогда
		
		НужныйТекстОшибки = "[" + Ошибка.ИмяТестовогоНабора + ": " + Ошибка.ИмяТестовогоСлучая + "] " + Ошибка.Описание;
		
	ИначеЕсли ТипОбъектаОшибка = Тип("ИнформацияОбОшибке") Тогда
		
		НужныйТекстОшибки = Ошибка.Описание;
		
	Иначе
		
		НужныйТекстОшибки = Ошибка;
		
	КонецЕсли;
	Возврат НужныйТекстОшибки;
КонецФункции

Функция ФорматДСО(ДопСообщениеОшибки)
	Если ДопСообщениеОшибки = "" Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Символы.ПС + ДопСообщениеОшибки;
КонецФункции

Функция СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(путьФайла) Экспорт
	Если НРег(Лев(путьФайла, 10)) = "обработка." Тогда
		путьФайла = Сред(путьФайла, 11);
	КонецЕсли;

	Попытка
		Возврат СоздатьОбъектОбработкиКонфигурации(путьФайла);
	Исключение
		Возврат ВнешниеОбработки.Создать(путьФайла, Ложь);
	КонецПопытки;

КонецФункции // СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим()

Функция СоздатьОбъектОбработкиКонфигурации(ИмяОбработки)
	Возврат Обработки[ИмяОбработки].Создать();
КонецФункции

// Устанавливает новое текущее состояние выполнения тестов
// в соответствии с приоритетами состояний:
// 		Красное - заменяет все другие состояния
// 		Желтое - заменяет только зеленое состояние
// 		Зеленое - заменяет только серое состояние (тест не выполнялся ни разу).
Функция ЗапомнитьСамоеХудшееСостояние(ТекущееСостояние, НовоеСостояние)
	
	ТекущееСостояние = Макс(ТекущееСостояние, НовоеСостояние);
	Возврат ТекущееСостояние;
	
КонецФункции

// Рекурсивно вверх от текущей строки меняет состояние у родительских строк.
// 
Процедура ИзменитьСостояниеВыполненияРодителей(СтрокаДереваТестов) Экспорт
	
	Если СтрокаДереваТестов.Родитель = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СтрокаРодителя = СтрокаДереваТестов.Родитель;
	ЗапомнитьСамоеХудшееСостояние(СтрокаРодителя.Состояние, СтрокаДереваТестов.Состояние);
	ИзменитьСостояниеВыполненияРодителей(СтрокаРодителя);
	
КонецПроцедуры

// Оповещает внешний мир о каком-либо событии. Используется
// для взаимодействия со скриптом Снегопата, а также с формой браузера 
// когда он запущен в режиме обычного приложения.
// 
Функция ОповеститьОСобытии(ИмяСобытия, Аргумент1=Неопределено)
	рез = Истина;
	Если mMiddleMan <> Неопределено Тогда
		Попытка
			Выполнить("mMiddleMan." + ИмяСобытия + "(Аргумент1);");			
		Исключение
			рез = Ложь;
		КонецПопытки;
	КонецЕсли;
	#Если Клиент Тогда 
		Оповестить("xUnitFor1C." + ИмяСобытия, Аргумент1);
	#КонецЕсли
	Возврат рез;
КонецФункции

Функция ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, имяМетода)
	Результат = Ложь;
	Если Найти(текстОшибки, "Метод объекта не обнаружен ("+имяМетода+")") > 0 
		ИЛИ Найти(текстОшибки, "Object method not found ("+имяМетода+")") > 0  Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура ЗаписатьКодВозвратаВЛогФайл(ПутьКФайлуЛога, КодВозврата, КодРезультатаТестирования = Неопределено) Экспорт
	ФайлЛога = Новый Файл(ПутьКФайлуЛога);
	КаталогЛога = Новый Файл(ФайлЛога.Путь);
	Проверить(КаталогЛога.Существует(), "Ожидали, что каталог лог-файла кода возврата будет существовать, а он не существует. <"+ФайлЛога.Путь+">");
	
	Запись = Новый ЗаписьТекста(ПутьКФайлуЛога);
	Запись.ЗаписатьСтроку(КодВозврата);
	Если КодРезультатаТестирования <> Неопределено Тогда
		Запись.ЗаписатьСтроку(КодРезультатаТестирования);
	КонецЕсли;
	Запись.Закрыть();
КонецПроцедуры

Процедура ЗарегистрироватьНачалоПрохожденияТеста(ИмяТестовогоСлучая, ПолныйПуть) Экспорт
	ЗаписьЖурналаРегистрации("xUnitFor1C.ЗапускТеста", 
    УровеньЖурналаРегистрации.Информация, , ,
    "Имя теста " + ИмяТестовогоСлучая+", путь теста "+ПолныйПуть);
КонецПроцедуры

Процедура ЗарегистрироватьОшибкуТеста(НужныйТекстОшибки, ИмяТестовогоСлучая, ПолныйПуть) Экспорт
	Если РегистрацияОшибокТестовВЖР Тогда
		ЗаписьЖурналаРегистрации("xUnitFor1C.ПадениеТеста", 
        УровеньЖурналаРегистрации.Ошибка, , ,
        "Имя теста " + ИмяТестовогоСлучая+", путь теста "+ПолныйПуть+Символы.ПС+НужныйТекстОшибки);
	КонецЕсли;
КонецПроцедуры

//}

//{ Обработка параметров командной строки
// Пример строки запуска для внешних файлов - "Тесты_Команда_Тестировать;E:\ТестыИМ\Тесты;ЗавершитьРаботуПослеТестирования"
//	"C:\Program Files (x86)\1cv82\8.2.18.96\bin\1cv8c.exe" /DisableStartupMessages /Execute E:\ТестыИМ\xddTestRunner.epf /S "as-msk-a6122\im_test" /Out "E:\ТестыИМ\Тесты\log.txt"  /C "Тесты_Команда_Тестировать;E:\ТестыИМ\Тесты;ЗавершитьРаботуПослеТестирования" /LogUI
//
// Пример строки запуска для внутренний тестов-обработок - "ЭтоТестИзКонфигурации;Тесты_Команда_Тестировать;Подсистемы.Тестирование;ЗавершитьРаботуПослеТестирования"
//	"C:\Program Files (x86)\1cv82\8.2.18.96\bin\1cv8c.exe" /DisableStartupMessages /Execute E:\ТестыИМ\xddTestRunner.epf /S "as-msk-a6122\im_test" /Out "E:\ТестыИМ\Тесты\log.txt"  /C "Тесты_Команда_Тестировать;E:\ТестыИМ\Тесты;ЗавершитьРаботуПослеТестирования" /LogUI
Функция РазобратьПараметрыЗапуска(СтрокаПараметровЗапуска) Экспорт
	
	РезСтруктураПараметров = СоздатьСтруктуруПараметровЗапуска();
	КоллекцияКомандЗапуска = СоздатьКоллекциюКомандЗапуска();
	
	путьКТестам = "";
	ПутьОтчетаТестирования = "";
	
	Если ПустаяСтрока(СтрокаПараметровЗапуска) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	параметрыЗапуска = ПолучитьМассивПараметровЗапуска(СтрокаПараметровЗапуска);
	
	МаксимальныйИндекс = параметрыЗапуска.ВГраница();
		
	Для Номер = 0 По МаксимальныйИндекс Цикл
		ЭлементМассива = параметрыЗапуска.Получить(Номер);
		
		лКомандаЗапуска = НРег(СокрЛП(ЭлементМассива));
		НомерМеньшеМаксимальногоИндекса = Номер < МаксимальныйИндекс;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.Выполнить, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			РезСтруктураПараметров.Выполнить = Истина;
			
			Номер=Номер+1;
			путьКТестам = СокрЛП(ПараметрыЗапуска[Номер]); 
			РезСтруктураПараметров.Загрузить = Истина; //естьКоманда_Загрузить = Истина;
			Продолжить;
				
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.Загрузить, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда 
			РезСтруктураПараметров.Загрузить = Истина;
			
			Номер=Номер+1;
			путьКТестам = СокрЛП(ПараметрыЗапуска[Номер]);
			Продолжить;
		КонецЕсли;		
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ОстановитьСистему, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.ОстановитьСистему = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ПутьОтчета, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			Номер=Номер+1;
			ПутьОтчетаТестирования = СокрЛП(ПараметрыЗапуска[Номер]);
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ФорматОтчета, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			Номер=Номер+1;
			РезСтруктураПараметров.ФорматОтчета = СокрЛП(ПараметрыЗапуска[Номер]);
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ПутьКодаВозврата, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			Номер=Номер+1;
			РезСтруктураПараметров.ПутьКодаВозврата = СокрЛП(ПараметрыЗапуска[Номер]);
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ВстроенныеТесты, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.ВстроенныеТесты = Истина;
		КонецЕсли;		

		Если НайтиКоманду(КоллекцияКомандЗапуска.РегистрацияПрохожденияТестовВЖР, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.РегистрацияПрохожденияТестовВЖР = Истина;
		КонецЕсли;		

		Если НайтиКоманду(КоллекцияКомандЗапуска.РегистрацияОшибокТестовВЖР, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.РегистрацияОшибокТестовВЖР = Истина;
		КонецЕсли;		
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ВыводЛогаВФорматеTeamCity, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.ВыводЛогаВФорматеTeamCity = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.РежимОтладки, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.РежимОтладки = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.СлучайныйПорядокВыполнения, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.СлучайныйПорядокВыполнения = Истина;
		КонецЕсли;

	КонецЦикла;
    
	Если Не РезСтруктураПараметров.Загрузить Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Найти(ВРег(путьКТестам), "МЕТАДАННЫЕ.") = 1 Тогда
		РезСтруктураПараметров.ВстроенныеТесты = Истина;
	КонецЕсли;
	
	РезСтруктураПараметров.ПутьТестов = путьКТестам;

	Если НЕ ПустаяСтрока(путьКТестам) И ПустаяСтрока(ПутьОтчетаТестирования) Тогда
		файл = Новый Файл(путьКТестам);
		Если файл.Существует() Тогда
			Если файл.ЭтоКаталог() Тогда
				ПутьОтчетаТестирования = путьКТестам + "\";
			Иначе
				ПутьОтчетаТестирования = файл.Путь + "\";
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли НЕ ПустаяСтрока(ПутьОтчетаТестирования) Тогда 
		файл = Новый Файл(ПутьОтчетаТестирования);
		Если файл.Существует() И файл.ЭтоКаталог() Тогда 
			ПутьОтчетаТестирования = ПутьОтчетаТестирования;
		ИначеЕсли ПустаяСтрока(файл.Расширение) Тогда
			ПутьОтчетаТестирования = файл.ПолноеИмя;
		ИначеЕсли Не Прав(ПутьОтчетаТестирования,1) = "\" Тогда 
			ПутьОтчетаТестирования = ПутьОтчетаТестирования+"\"; //FIXME: для linux это не подойдет. 
		КонецЕсли;
	КонецЕсли;
	РезСтруктураПараметров.ПутьОтчета = ПутьОтчетаТестирования;
	
	Возврат РезСтруктураПараметров;		
КонецФункции

Функция ПолучитьМассивПараметровЗапуска(СтрокаПараметровЗапуска)

	Если ПустаяСтрока(СтрокаПараметровЗапуска) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Параметр может состоять из частей, разделенных символом ";".
	// Первая часть - главное значение параметра запуска. 
	// Наличие дополнительных частей определяется логикой обработки главного параметра.
	ПараметрыЗапуска = РазложитьСтрокуВМассивПодстрок(СтрокаПараметровЗапуска, ";");
	
	Возврат ПараметрыЗапуска;
	
КонецФункции

// Разбивает строку на несколько строк по разделителю. Разделитель может иметь любую длину.
// Общий модуль СтроковыеФункцииКлиентСервер.
//
// Параметры:
//  Строка                 - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Примеры:
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",") - возвратит массив из 5 элементов, три из которых  - пустые строки;
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина) - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок(" один   два  ", " ") - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("") - возвратит пустой массив;
//  РазложитьСтрокуВМассивПодстрок("",,Ложь) - возвратит массив с одним элементом "" (пустой строкой);
//  РазложитьСтрокуВМассивПодстрок("", " ") - возвратит массив с одним элементом "" (пустой строкой);
//
//&НаКлиенте
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

Функция СоздатьСтруктуруПараметровЗапуска()
	Рез = Новый Структура;
	Рез.Вставить("ПутьТестов", Ложь);
	Рез.Вставить("Выполнить", Ложь);
	Рез.Вставить("Загрузить", Ложь);
	Рез.Вставить("ОстановитьСистему", Ложь);
	Рез.Вставить("ВстроенныеТесты", Ложь);
	Рез.Вставить("ПутьОтчета", "");
	Рез.Вставить("ФорматОтчета", "");
	Рез.Вставить("ПутьКодаВозврата", "");
	Рез.Вставить("РегистрацияПрохожденияТестовВЖР", Ложь);
	Рез.Вставить("РегистрацияОшибокТестовВЖР", Ложь);
	Рез.Вставить("ВыводЛогаВФорматеTeamCity", Ложь);
	Рез.Вставить("РежимОтладки", Ложь);
	Рез.Вставить("СлучайныйПорядокВыполнения", Ложь);
	Возврат Рез;
КонецФункции

Функция СоздатьКоллекциюКомандЗапуска()
	Рез = СоздатьСтруктуруПараметровЗапуска();
	Рез.Вставить("Выполнить", Новый Структура("Р,А", "Тесты_Команда_Тестировать","xddRun"));
	Рез.Вставить("Загрузить", Новый Структура("Р,А", "Тесты_Команда_Загрузить","xddLoad"));
	Рез.Вставить("ОстановитьСистему", Новый Структура("Р,А", "ЗавершитьРаботуПослеТестирования","xddShutdown"));
	Рез.Вставить("ВстроенныеТесты", Новый Структура("Р,А", "ЭтоТестИзКонфигурации","xddConfig"));
	Рез.Вставить("ПутьОтчета", Новый Структура("Р,А", "Тесты_Команда_КаталогОтчетов","xddReportPath"));
	Рез.Вставить("ФорматОтчета", Новый Структура("Р,А", "Тесты_Команда_ФорматОтчета","xddReportFormat"));
	Рез.Вставить("ПутьКодаВозврата", Новый Структура("Р,А", "Тесты_Путь_КЛогам","xddExitCodePath"));
	Рез.Вставить("РегистрацияПрохожденияТестовВЖР", Новый Структура("Р,А", "Тесты_ЗаписьВЖР","xddWriteLogEvent"));
	Рез.Вставить("РегистрацияОшибокТестовВЖР", Новый Структура("Р,А", "Тесты_ЗаписьОшибокВЖР","xddWriteErrorIntoLogEvent"));
	Рез.Вставить("ВыводЛогаВФорматеTeamCity", Новый Структура("Р,А", "Тесты_ФорматСообщенийTeamCity","xddLogForTeamCity"));
	Рез.Вставить("РежимОтладки", Новый Структура("Р,А", "Тесты_РежимОтадки","xddDebugMode"));
	Рез.Вставить("СлучайныйПорядокВыполнения", Новый Структура("Р,А", "Тесты_СлучайныйПорядок","xddRandomOrder"));
	Возврат Рез;
КонецФункции

Функция НайтиКоманду(КоллекцияКоманды, КомандаЗапускаНРег)
	Для каждого КлючЗначение Из КоллекцияКоманды Цикл
		Если НРег(КлючЗначение.Значение) = КомандаЗапускаНРег Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции
//}

//{ Работа со встроенными в конфигурация тестами и подсистемами
Процедура ЗаполнитьДеревоПодсистем(ДеревоПодсистем, ОтборПоИмениТеста) Экспорт
	Для каждого МетаПодсистема из Метаданные.Подсистемы цикл
		ДобавитьПодсистемуВДерево(МетаПодсистема, ДеревоПодсистем, ЭтотОбъект, ОтборПоИмениТеста);
	КонецЦикла;
	ОчиститьДерево(ДеревоПодсистем);
КонецПроцедуры

Функция ДобавитьПодсистемуВДерево(ТекМетаПодсистема, РодительскаяСтрока, ОбработкаОбъект, ОтборПоИмениТеста)
	СтрокаПодсистемы = ПодчиненныеСтроки(РодительскаяСтрока).Добавить(); //СтрокаДерева.Строки.Добавить();
	СтрокаПодсистемы.Имя = ТекМетаПодсистема.Имя;
	СтрокаПодсистемы.Путь = "Метаданные."+СтрЗаменить(ТекМетаПодсистема.ПолноеИмя(), "Подсистема.", "Подсистемы.");
	СтрокаПодсистемы.ТипСтроки = "Подсистема";
	Для Каждого Подсистема из ТекМетаПодсистема.Подсистемы Цикл 
		ДобавитьПодсистемуВДерево(Подсистема,СтрокаПодсистемы, ОбработкаОбъект, ОтборПоИмениТеста);
	КонецЦикла;
	
	Для каждого ОбъектМетаданных из ТекМетаПодсистема.Состав цикл
		//Если Лев(ОбъектМетаданных.ПолноеИмя(),15) = "Обработка.Тест_" Тогда
		Если Найти(ОбъектМетаданных.ПолноеИмя(), "Обработка."+ОтборПоИмениТеста) = 1 Тогда
			СтрокаТеста = ПодчиненныеСтроки(СтрокаПодсистемы).Добавить();
			СтрокаТеста.Имя = ОбъектМетаданных.Имя;
			СтрокаТеста.Путь = "Метаданные."+СтрЗаменить(ОбъектМетаданных.ПолноеИмя(), "Обработка.", "Обработки.");
			СтрокаТеста.ТипСтроки = "Тест";
			СтрокаТеста.ИмеетТесты = Истина;
			ОбработкаОбъект.ПометитьРодителя(СтрокаТеста);
		КонецЕсли;
	КонецЦикла;
КонецФункции
//}

Функция ПодчиненныеСтроки(СтрокаДерева, РезЭтоСтрокаДереваУФ = Ложь) Экспорт
	РезЭтоСтрокаДереваУФ = ЭтоСтрокаДереваУФ(СтрокаДерева);
    Если Не РезЭтоСтрокаДереваУФ Тогда
        Строки = СтрокаДерева.Строки;
    Иначе
        Строки = СтрокаДерева.ПолучитьЭлементы();
	КонецЕсли;
	Возврат Строки;
КонецФункции

Функция РодительскаяСтрока(СтрокаДерева, РезЭтоСтрокаДереваУФ = Ложь)
	РезЭтоСтрокаДереваУФ = ЭтоСтрокаДереваУФ(СтрокаДерева);
    Если Не РезЭтоСтрокаДереваУФ Тогда
        Родитель = СтрокаДерева.Родитель;
    Иначе
        Родитель = СтрокаДерева.ПолучитьРодителя();
	КонецЕсли;
	Возврат Родитель;
КонецФункции

Функция ЭтоСтрокаДереваУФ(СтрокаДерева)
	Рез = Ложь;
    Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") ИЛИ ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
    ИначеЕсли ТипЗнч(СтрокаДерева) = Тип("ДанныеФормыЭлементДерева") ИЛИ ТипЗнч(СтрокаДерева) = Тип("ДанныеФормыДерево") Тогда
		Рез = Истина;
	КонецЕсли;
	Возврат Рез;
КонецФункции

// Возвращает объект метаданных по переданному полному строковому пути
//
Функция ПолучитьОбъектМетаданныхПоПути(ПутьКОбъекту) Экспорт
	//ВыражениеПодсистема = "Метаданные."+СтрЗаменить(Путь, "Подсистема.", "Подсистемы.");
	ОбъектКонфигурации = Неопределено;
	Попытка
		Выполнить("ОбъектКонфигурации = "+ПутьКОбъекту);
	Исключение
	КонецПопытки;	
	Возврат ОбъектКонфигурации;
КонецФункции

Функция ЭтоВнешняяОбработка(ПарамОбъект = Неопределено) Экспорт
	Перем НужныйОбъект;
	НужныйОбъект = ПарамОбъект;
	Если НужныйОбъект = Неопределено Тогда
		НужныйОбъект = ЭтотОбъект;
	КонецЕсли;
	Рез = Метаданные.НайтиПоТипу(ТипЗнч(НужныйОбъект)) = Неопределено;
	Возврат Рез; 
КонецФункции

Процедура ПодключитьИнформатор() Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		мПытаемсяСоздатьИнформатор = Истина;
		Если ЗапретИспользованияИнформатора Тогда
			мПытаемсяСоздатьИнформатор = Ложь;
		КонецЕсли;

		Если мПытаемсяСоздатьИнформатор Тогда
			ПолучитьИнформатор();
		КонецЕсли; 
	#Иначе
		мПытаемсяСоздатьИнформатор = Ложь;
	#КонецЕсли
	
КонецПроцедуры

Процедура ЗарегистрироватьОшибкуЗапускаТестирования(ПолныйПуть, ОписаниеОшибки) Экспорт
	ЗаписьЖурналаРегистрации("xUnitFor1C.ТестированиеНеВыполнено", 
    УровеньЖурналаРегистрации.Информация, , ,
    ОписаниеОшибки+", путь "+ПолныйПуть);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ  СОБЫТИЙ ОБЪЕКТА

////////////////////////////////////////////////////////////////////////////////
// ОПЕРАТОРЫ ОСНОВНОЙ ПРОГРАММЫ

//{ Состояния тестов - ВАЖЕН порядок заполнения в мЗначенияСостоянияТестов, используется в ЗапомнитьСамоеХудшееСостояние
мЗначенияСостоянияТестов = Новый Структура;
мЗначенияСостоянияТестов.Вставить("НеВыполнялся", 0);
мЗначенияСостоянияТестов.Вставить("Прошел"		, 1);
мЗначенияСостоянияТестов.Вставить("НеРеализован", 2);
мЗначенияСостоянияТестов.Вставить("Сломался"	, 3);
мЗначенияСостоянияТестов = Новый ФиксированнаяСтруктура(мЗначенияСостоянияТестов);
//} Состояния тестов

//{ Типы строк дерева тестов
мЗначенияТиповСтроки = Новый Структура;
мЗначенияТиповСтроки.Вставить("КаталогТестов", 0);
мЗначенияТиповСтроки.Вставить("ТестовыйСлучай", 1);
мЗначенияТиповСтроки.Вставить("ТестовыйМетод", 2);
мЗначенияТиповСтроки.Вставить("Подсистема", 3);
мЗначенияТиповСтроки = Новый ФиксированнаяСтруктура(мЗначенияТиповСтроки);
//} Типы строк дерева тестов

мЗначениеМодульИлиФорма = Новый Структура();
мЗначениеМодульИлиФорма.Вставить("Модуль", 1);
мЗначениеМодульИлиФорма.Вставить("Форма", 2);
мЗначениеМодульИлиФорма = Новый ФиксированнаяСтруктура(мЗначениеМодульИлиФорма);

//{ Соответствие Статуса сообщения 1с Статусу в Buildlog TeamCity
мСоответствиеСтатусовДляTeamCity = Новый Соответствие;
мСоответствиеСтатусовДляTeamCity.Вставить(Неопределено,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.БезСтатуса,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Обычное,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Информация,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Внимание,"WARNING");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Важное,"FAILURE");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.ОченьВажное,"ERROR");
мСоответствиеСтатусовДляTeamCity = Новый ФиксированноеСоответствие(мСоответствиеСтатусовДляTeamCity);
//} Соответствие Статуса сообщения 1с Статусу в Buildlog TeamCity

//{ Инициализация дерева тестов
ДеревоТестов.Колонки.Добавить("Имя");
ДеревоТестов.Колонки.Добавить("ВремяВыполнения");
ДеревоТестов.Колонки.Добавить("ПолныйПуть");
//ДеревоТестов.Колонки.Добавить("ПредставлениеПути");
ДеревоТестов.Колонки.Добавить("ТипСтроки");
ДеревоТестов.Колонки.Добавить("Состояние");
ДеревоТестов.Колонки.Добавить("МодульИлиФорма");
//ДеревоТестов.Колонки.Добавить("_Объект");
ДеревоТестов.Колонки.Добавить("_guid");
ДеревоТестов.Колонки.Добавить("ПараметрыТеста");
ДеревоТестов.Колонки.Добавить("ЕстьПараметрыТеста");
ДеревоТестов.Колонки.Добавить("ИмяТестовогоСлучая");
ДеревоТестов.Колонки.Добавить("КоличествоТестов");
ДеревоТестов.Колонки.Добавить("ЭтоВнутренняяОбработка");
ДеревоТестов.Колонки.Добавить("ИмеетТесты");
//Необходимость вызова искуственного исключения перед тестом для перехвата в отладчике.
ДеревоТестов.Колонки.Добавить("ВызыватьИсключение", Новый ОписаниеТипов("Булево")); 
//} Инициализация дерева тестов

ОшибкиСравненияТаблиц = Новый Структура;
ОшибкиСравненияТаблиц.Вставить("ВидОшибки_НетОшибок", 0);
ОшибкиСравненияТаблиц.Вставить("ВидОшибки_НеСовпадаютЗначенияВЯчейкеТаблицы", 1);
ОшибкиСравненияТаблиц.Вставить("ВидОшибки_РазноеКоличествоСтрок", 2);
ОшибкиСравненияТаблиц.Вставить("ВидОшибки_ВРезультатеКолонкиНеСовпадают", 3);
ОшибкиСравненияТаблиц = Новый ФиксированнаяСтруктура(ОшибкиСравненияТаблиц);

мИнформатор = Неопределено;

//#Если ТолстыйКлиентОбычноеПриложение Тогда
//	
//	мПытаемсяСоздатьИнформатор = Истина;
//	Если ЗапретИспользованияИнформатора Тогда
//		мПытаемсяСоздатьИнформатор = Ложь;
//	КонецЕсли;

//	Если мПытаемсяСоздатьИнформатор Тогда
//		ПолучитьИнформатор();
//	КонецЕсли; 
//#Иначе
//	мПытаемсяСоздатьИнформатор = Ложь;
//#КонецЕсли

мКоличествоТестовыхСлучаев  = 0;

ЭтоВстроеннаяОбработка = Не Метаданные.НайтиПоТипу(ТипЗнч(ЭтотОбъект)) = Неопределено;
