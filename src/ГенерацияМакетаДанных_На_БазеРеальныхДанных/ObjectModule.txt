Перем ТестовыеДанныхДляУдаления;

//{ основная процедура для юнит-тестирования xUnitFor1C
Перем юТест;

Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
	
	юТест = ЮнитТестирование;
	
	ВсеТесты = Новый Массив;
	
	//юТест.ДобавитьПростыеТестыИзОбъекта(ВсеТесты, ЭтотОбъект);

	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияПростогоСправочника");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияОбъектаСЗаполненнымРеквизитомТипаПеречисление");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДвухПростыхСправочников");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДвухСвязанныхСправочников");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияСправочникаСРеквизитомСсылка_РежимПоискаКод");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияСправочникаСДвумяСтрокамиВТабличнойЧасти");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДокументаСДвумяСтрокамиВТабличнойЧасти");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияДвухЗаписейВРегистреСведений");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияПодчиненногоСправочника");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСозданияИерархическогоСправочника");
	ВсеТесты.Добавить("ТестДолжен_ПолучитьМакетДляСоздания2ЗаписейРегистраСведений");

	Возврат ВсеТесты;
	
КонецФункции
//}

//{ ОСНОВНОЙ БЛОК
Функция СоздатьМакетДляГенерацииДанных(МассивДанных) Экспорт
	ШапкаДанных = ШапкаДанныхВМакете();
	Макет = Новый  ТабличныйДокумент;	
	номерКолонки = 0;
	Для каждого ключЗначение Из ШапкаДанных Цикл
		номерКолонки = номерКолонки + 1;
		имяПоля = ключЗначение.Ключ;
		Макет.Область(1, номерКолонки, 1, номерКолонки).Текст = имяПоля ;
	КонецЦикла;
	
	Для каждого ОписательОбъекта Из МассивДанных Цикл
		ДобавитьОбъектВМакет(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных);
	КонецЦикла;
	Возврат Макет;
КонецФункции

//{ Пример вызова из внешнего кода:
//		Путь_xUnitFor1C = "C:\Projects\GitHub\xUnitFor1C\";
//		ПутьГенератораМакета = Путь_xUnitFor1C + "ГенерацияМакетаДанных_На_БазеРеальныхДанных.epf";
//		Запрос = Новый Запрос;
//		запрос.Текст = "
//		|ВЫБРАТЬ
//		|	""РегистрыСведений.РегистрСведений1.СоздатьНаборЗаписей().Метаданные()"" КАК __Метаданные,
//		|	""ЗаписьРегистра"" КАК __Префикс,
//		|	РегистрСведений1.ПростойСправочник,
//		|	РегистрСведений1.ПростойСправочник2,
//		|	РегистрСведений1.РесурсЧисло,
//		|	РегистрСведений1.РесурсБулево
//		|ИЗ
//		|	РегистрСведений.РегистрСведений1 КАК РегистрСведений1";
//		РезультатЗапроса = Запрос.Выполнить();
//
//		ГенераторМакетаДанных = ВнешниеОбработки.Создать(ПутьГенератораМакета);
//		Макет = ГенераторМакетаДанных.СоздатьМакетДанныхНаОснованииЗапроса(РезультатЗапроса);
//		Макет.Показать();
//}
Функция СоздатьМакетДанныхНаОснованииЗапроса(РезультатЗапроса) Экспорт
	Таблица = РезультатЗапроса.Выгрузить();
	
	МассивПропускаемыхКолонок = Новый Массив;
	МассивПропускаемыхКолонок.Добавить("__Метаданные");
	МассивПропускаемыхКолонок.Добавить("__Префикс");
	СтрокаПропускаемыхКолонок = "";
	Для каждого Колонка Из МассивПропускаемыхКолонок Цикл
		СтрокаПропускаемыхКолонок = СтрокаПропускаемыхКолонок + Колонка+", ";
	КонецЦикла;
	
	КоличествоСлужебныхКолонок = МассивПропускаемыхКолонок.Количество();
	
	СтруктураДанных = Новый Структура();
	для каждого КолонкаЗапроса из Таблица.Колонки цикл
		Если МассивПропускаемыхКолонок.Найти(КолонкаЗапроса.Имя) <> Неопределено Тогда
			КоличествоСлужебныхКолонок = КоличествоСлужебныхКолонок - 1;
			Продолжить;
		КонецЕсли;
		
		имяКолонки = КолонкаЗапроса.имя;
		СтруктураДанных.Вставить(имяКолонки);
	КонецЦикла;
	
	Если КоличествоСлужебныхКолонок <> 0 Тогда
		ВызватьИсключение "Не все служебные колонки заданы! В запросе обязательно должны быть колонки "+СтрокаПропускаемыхКолонок;
	КонецЕсли;
	
	МассивДанных = Новый Массив;
			
	номер = 1;
	индекс = 1;
	Для каждого Строка из Таблица Цикл
		номер = номер + 1;
		
		ИмяПеременной = Строка.__Префикс + индекс;
		РеквизитыЗаписи = Новый Структура();
		Для каждого ключЗначение Из СтруктураДанных Цикл
			РеквизитыЗаписи.Вставить(ключЗначение.Ключ)
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(РеквизитыЗаписи, Строка);
		
		Мета = Неопределено;
		Выполнить("Мета = "+Строка.__Метаданные);
		
		описаниеЗаписиРегистраСведений1 = СоздатьОписательЭлемента();
		описаниеЗаписиРегистраСведений1.Вставить("Метаданное", Мета);
		описаниеЗаписиРегистраСведений1.Вставить("ИмяПеременной", ИмяПеременной);	
		описаниеЗаписиРегистраСведений1.Вставить("Реквизиты", РеквизитыЗаписи);	
		
		МассивДанных.Добавить(описаниеЗаписиРегистраСведений1);

		индекс = индекс + 1;
	КонецЦикла;
	
	Макет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	Возврат Макет;
КонецФункции

Функция СоздатьОписательЭлемента() Экспорт
	ОписательЭлемента = Новый Структура;
	ОписательЭлемента.Вставить("Ссылка");
	ОписательЭлемента.Вставить("ИмяПеременной", "");
	ОписательЭлемента.Вставить("Метаданное");
	ОписательЭлемента.Вставить("ВыгружатьКод", Ложь);
	ОписательЭлемента.Вставить("РежимПоиска", "");
	ОписательЭлемента.Вставить("Реквизиты", "");
	Возврат ОписательЭлемента;
КонецФункции

Функция ПолучитьИдентификаторПредставленияПоСсылке(Ссылка) Экспорт
	Мд = Ссылка.Метаданные();
	
	менеджерОбъекта = ПолучитьМенеджерОбъекта_ирЛкс(Мд);
	КорневойТипКонфигурации = ПолучитьКорневойТипКонфигурации_ирЛкс(Мд);
	
	Представление = "";
	Если КорневойТипКонфигурации = "Справочник" Тогда
		Представление = Ссылка.Наименование;
	ИначеЕсли КорневойТипКонфигурации = "Документ" Тогда
		Представление = ""+Ссылка;
	//ИначеЕсли КорневойТипКонфигурации = "РегистрСведений" Тогда 
	Иначе
		ВызватьИсключение "ПолучитьИдентификаторПредставленияПоСсылке() : Неизвестный КорневойТипКонфигурации <"+КорневойТипКонфигурации+">";
	КонецЕсли;
	рез = ПолучитьИдентификаторИзПредставления_Лкс(Представление, Неопределено, "_");
	Возврат рез;
КонецФункции

Процедура ДобавитьОбъектВМакет(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных)
	//ЭтоСсылочныйОбъект = Ложь;
	Ссылка = Неопределено;
	Мд = Неопределено;
	ЭтоСсылочныйОбъект = ЭтоОписательОбъектаСсылки(ОписательОбъекта, Ссылка);
	Если ЭтоСсылочныйОбъект Тогда
		ЭтоСсылочныйОбъект = Истина;
		Мд = Ссылка.Метаданные();
	ИначеЕсли ОписательОбъекта.Свойство("Метаданное", Мд) Тогда
	КонецЕсли;
	
	ДобавитьМетаданныеВМакетДляДобавляемогоОбъекта(Макет, ОписательОбъекта, ШапкаДанных, Макет.ВысотаТаблицы+1, Мд);
	
	менеджерОбъекта = ПолучитьМенеджерОбъекта_ирЛкс(Мд);
	КорневойТипКонфигурации = ПолучитьКорневойТипКонфигурации_ирЛкс(Мд);
	Если КорневойТипКонфигурации = "Справочник" Тогда
		лПустойОбъект = менеджерОбъекта.СоздатьЭлемент();	
	ИначеЕсли КорневойТипКонфигурации = "Документ" Тогда
		лПустойОбъект = менеджерОбъекта.СоздатьДокумент();	
	ИначеЕсли КорневойТипКонфигурации = "РегистрСведений" Тогда 
	Иначе
		ВызватьИсключение "Неизвестный КорневойТипКонфигурации <"+КорневойТипКонфигурации+">";
	КонецЕсли;
	
	ВыгружаемыеСтандартныеРеквизиты = ВыгружаемыеСтандартныеРеквизиты(ОписательОбъекта, КорневойТипКонфигурации);
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		объект = Ссылка.ПолучитьОбъект();
	
		ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, лПустойОбъект, Мд.СтандартныеРеквизиты, ВыгружаемыеСтандартныеРеквизиты);
		ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, лПустойОбъект, Мд.Реквизиты, Неопределено);
		
		ОбработатьТабличныеЧастиОбъекта(Макет, Мд.ТабличныеЧасти, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект);
	ИначеЕсли КорневойТипКонфигурации = "РегистрСведений" Тогда
		ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Мд, Неопределено, Мд.СтандартныеРеквизиты, ВыгружаемыеСтандартныеРеквизиты);
		ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Мд, Неопределено, Мд.Измерения, Неопределено);
		ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Мд, Неопределено, Мд.Ресурсы, Неопределено);
		ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Мд, Неопределено, Мд.Реквизиты, Неопределено);
	Иначе
		ВызватьИсключение "Неизвестный вариант работы - метод <ДобавитьОбъектВМакет>";
	КонецЕсли;
КонецПроцедуры

Процедура ДобавитьМетаданныеВМакетДляДобавляемогоОбъекта(Макет, ОписательОбъекта, ШапкаДанных, НомерСтрокиМакета, Мд)
	НомерКолонкиМакета_Тип = ШапкаДанных.Тип;
	ОбластьМакета = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Тип, НомерСтрокиМакета, НомерКолонкиМакета_Тип);
	ОбластьМакета.Текст = ПолучитьКорневойТипКонфигурации_ирЛкс(Мд);
	
	НомерКолонкиМакета_Вид = ШапкаДанных.Вид;
	ОбластьМакета = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Вид, НомерСтрокиМакета, НомерКолонкиМакета_Вид);
	ОбластьМакета.Текст = Мд.Имя;
	
	НомерКолонкиМакета_ИмяПеременной = ШапкаДанных.ИмяПеременной;
	ОбластьМакета = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_ИмяПеременной, НомерСтрокиМакета, НомерКолонкиМакета_ИмяПеременной);
	
	ИмяПеременной = ИмяПеременнойИзОписателяОбъекта(Мд, ОписательОбъекта);
	ОбластьМакета.Текст = ИмяПеременной;
КонецПроцедуры

Функция ВыгружаемыеСтандартныеРеквизиты(ОписательОбъекта, КорневойТипКонфигурации)
	ВыгружаемыеСтандартныеРеквизиты = Новый Массив;
	Если КорневойТипКонфигурации = "Справочник" Тогда
		ВыгружаемыеСтандартныеРеквизиты.Добавить("Наименование");
		ВыгружаемыеСтандартныеРеквизиты.Добавить("ПометкаУдаления");
		ВыгружатьКод = Ложь;
		Если ОписательОбъекта.Свойство("ВыгружатьКод", ВыгружатьКод) и ВыгружатьКод Тогда
			ВыгружаемыеСтандартныеРеквизиты.Добавить("Код");
		КонецЕсли;
		МетаданныеСправочника = ОписательОбъекта.Ссылка.Метаданные();
		Если МетаданныеСправочника.Владельцы.Количество() > 0 Тогда
			ВыгружаемыеСтандартныеРеквизиты.Добавить("Владелец");
		КонецЕсли;
		Если МетаданныеСправочника.Иерархический Тогда
			ВыгружаемыеСтандартныеРеквизиты.Добавить("Родитель");
		КонецЕсли;
	ИначеЕсли КорневойТипКонфигурации = "Документ" Тогда
		ВыгружаемыеСтандартныеРеквизиты.Добавить("Дата");
		ВыгружаемыеСтандартныеРеквизиты.Добавить("ПометкаУдаления");
		//ВыгружаемыеСтандартныеРеквизиты.Добавить("Проведен");
		ВыгружатьКод = Ложь;
		Если ОписательОбъекта.Свойство("ВыгружатьКод", ВыгружатьКод) и ВыгружатьКод Тогда
			ВыгружаемыеСтандартныеРеквизиты.Добавить("Номер");
		КонецЕсли;
	ИначеЕсли КорневойТипКонфигурации = "РегистрСведений" Тогда 
		//Для каждого МдРеквизит Из ОписательОбъекта.Метаданное.СтандартныеРеквизиты Цикл
		//	Сообщить("МдРеквизит.Имя = <"+?(МдРеквизит.Имя = Неопределено, "Неопределено", МдРеквизит.Имя)+">"); 
		//КонецЦикла;
	Иначе
		ВызватьИсключение "Неизвестный КорневойТипКонфигурации <"+КорневойТипКонфигурации+"> КорневойТипКонфигурации()";
	КонецЕсли;
	
	Возврат ВыгружаемыеСтандартныеРеквизиты;
КонецФункции

Процедура ОбработатьРеквизитыОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, лПустойОбъект, МдРеквизиты, ВыгружаемыеРеквизиты)
	НомерСтрокиМакета = Макет.ВысотаТаблицы+1;
	
	ЭтоСсылочныйОбъект = ЭтоОписательОбъектаСсылки(ОписательОбъекта); //ЭтоСсылочныйОбъект = ОписательОбъекта.Свойство("Ссылка");
	Если ЭтоСсылочныйОбъект Тогда
		Мд = Объект.Метаданные();
	Иначе
		Мд = Объект;
	КонецЕсли;

	Для каждого РеквизитМд Из МдРеквизиты Цикл
		имяРеквизита = РеквизитМд.Имя;
		Если ВыгружаемыеРеквизиты <> Неопределено и ВыгружаемыеРеквизиты.Найти(имяРеквизита) = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если ЭтоСсылочныйОбъект Тогда
			ЗначениеРеквизита = объект[имяРеквизита];

			этоЗначениеБудетСозданоПоУмолчанию = лПустойОбъект[имяРеквизита] = ЗначениеРеквизита;
			Если этоЗначениеБудетСозданоПоУмолчанию Тогда
				Продолжить;
			КонецЕсли;
		Иначе
			ЗначениеРеквизита = ОписательОбъекта.Реквизиты[имяРеквизита];
		КонецЕсли;
		
		ДобавилиРеквизит = ОбработатьРеквизитОбъекта(Макет, МассивДанных, имяРеквизита, ЗначениеРеквизита, Мд, НомерСтрокиМакета, ШапкаДанных);
		
		Если ДобавилиРеквизит Тогда
			НомерСтрокиМакета = НомерСтрокиМакета + 1;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьТабличныеЧастиОбъекта(Макет, МдТабличныеЧасти, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект)
	Для каждого МдТч Из МдТабличныеЧасти Цикл
		МдРеквизиты = МдТч.Реквизиты;
		ИмяТЧ = МдТч.Имя;
		
		НомерКолонкиМакета_ТЧ = ШапкаДанных.ТЧ;
		
		Для каждого строкаТчОбъекта Из объект[ИмяТЧ] Цикл
			НомерСтрокиМакета = Макет.ВысотаТаблицы+1;
			ОбластьМакета = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_ТЧ, НомерСтрокиМакета, НомерКолонкиМакета_ТЧ);
			ОбластьМакета.Текст = ИмяТЧ;
			
			ОбработатьРеквизитыТабличнойЧастиОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, строкаТчОбъекта, МдРеквизиты);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьРеквизитыТабличнойЧастиОбъекта(Макет, ОписательОбъекта, ШапкаДанных, МассивДанных, Объект, строкаТчОбъекта, МдРеквизиты)
	НомерСтрокиМакета = Макет.ВысотаТаблицы+1;
	
	Мд = Объект.Метаданные();

	Для каждого РеквизитМд Из МдРеквизиты Цикл
		имяРеквизита = РеквизитМд.Имя;

		ЗначениеРеквизита = строкаТчОбъекта[имяРеквизита];

		ДобавилиРеквизит = ОбработатьРеквизитОбъекта(Макет, МассивДанных, имяРеквизита, ЗначениеРеквизита, Мд, НомерСтрокиМакета, ШапкаДанных);

		Если ДобавилиРеквизит Тогда
			НомерСтрокиМакета = НомерСтрокиМакета + 1;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция ОбработатьРеквизитОбъекта(Макет, МассивДанных, имяРеквизита, ЗначениеРеквизита, Мд, НомерСтрокиМакета, ШапкаДанных)
	ТипРеквизита = ТипЗнч(ЗначениеРеквизита);
	Если Не ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПредставлениеЗначенияРеквизита = "";
	РежимПоиска = "";
	Попытка
		ПолучитьПредставлениеИРежимПоискаПоЗначениюРеквизита(ЗначениеРеквизита, ТипРеквизита, МассивДанных, ПредставлениеЗначенияРеквизита, РежимПоиска);
	Исключение
		описаниеОшибки = ОписаниеОшибки();
		ВызватьИсключение описаниеОшибки + " Не умею обрабатывать реквизит <"+имяРеквизита+"> у объекта <"+Мд.ПолноеИмя()+">";
	КонецПопытки;
	
	НомерКолонкиМакета_Реквизит = ШапкаДанных.Реквизит;
	НомерКолонкиМакета_Значение = ШапкаДанных.Значение;
	НомерКолонкиМакета_Режим = ШапкаДанных.Режим;
	
	ОбластьМакета_Реквизит = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Реквизит, НомерСтрокиМакета, НомерКолонкиМакета_Реквизит);
	ОбластьМакета_Реквизит.Текст = имяРеквизита;
	
	ОбластьМакета_Значение = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Значение, НомерСтрокиМакета, НомерКолонкиМакета_Значение);
	ОбластьМакета_Режим = Макет.Область(НомерСтрокиМакета, НомерКолонкиМакета_Режим, НомерСтрокиМакета, НомерКолонкиМакета_Режим);
	
	ОбластьМакета_Значение.Текст = ПредставлениеЗначенияРеквизита;
	Если РежимПоиска <> "" Тогда
		ОбластьМакета_Режим.Текст = РежимПоиска;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Процедура ПолучитьПредставлениеИРежимПоискаПоЗначениюРеквизита(ЗначениеРеквизита, ТипРеквизита, МассивДанных, резПредставлениеЗначенияРеквизита, резРежимПоиска)
	Если ТипРеквизита = Тип("Число") Тогда
		ПредставлениеЗначенияРеквизита = Формат(ЗначениеРеквизита, "ЧГ=");
	ИначеЕсли ТипРеквизита = Тип("Строка") Тогда
		ПредставлениеЗначенияРеквизита = ЗначениеРеквизита;
	ИначеЕсли ТипРеквизита = Тип("Дата") Тогда
		ПредставлениеЗначенияРеквизита = Формат(ЗначениеРеквизита, "ДФ=yyyyMMdd");
	ИначеЕсли ТипРеквизита = Тип("Булево") Тогда
		ПредставлениеЗначенияРеквизита = Формат(ЗначениеРеквизита, "БЛ=Ложь; БИ=Истина");			
		
	ИначеЕсли ЛиСсылкаНаОбъектБД_ирЛкс(ЗначениеРеквизита) Тогда
		ОписательЗначенияРеквизита = НайтиОписательОбъектаПоСсылке(МассивДанных, ЗначениеРеквизита); //МассивДанных.Найти(ЗначениеРеквизита);
		Если ОписательЗначенияРеквизита <> Неопределено Тогда
			ПредставлениеЗначенияРеквизита = ИмяПеременнойИзОписателяОбъекта(ЗначениеРеквизита.Метаданные(), ОписательЗначенияРеквизита);
			РежимПоиска = "Перем";
		Иначе
			ПредставлениеЗначенияРеквизита = ЗначениеРеквизита;
			РежимПоиска = "Наименование";
		КонецЕсли;
		
	ИначеЕсли ЛиСсылкаНаПеречисление_ирЛкс(ЗначениеРеквизита) Тогда
		ПредставлениеЗначенияРеквизита = "";
		Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
			ИмяПеречисления = ЗначениеРеквизита.Метаданные().Имя;
			ИндексЗначения = Перечисления[ИмяПеречисления].Индекс(ЗначениеРеквизита);
			ИмяЗначения = Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначения].Имя;
		КонецЕсли;
		ПредставлениеЗначенияРеквизита = ИмяЗначения;
		РежимПоиска = "Предопределенный";
		
	Иначе
		ВызватьИсключение "Генератор макета из реальных данных: Не умею обрабатывать такой тип <"+ТипРеквизита+">";
	КонецЕсли;
	резПредставлениеЗначенияРеквизита = ПредставлениеЗначенияРеквизита;
	резРежимПоиска = РежимПоиска;
КонецПроцедуры

Функция НайтиОписательОбъектаПоСсылке(МассивДанных, Ссылка)
	Для каждого ОписательОбъекта Из МассивДанных Цикл
		СсылкаВрем = Неопределено;
		Если ЭтоОписательОбъектаСсылки(ОписательОбъекта, СсылкаВрем) и СсылкаВрем = Ссылка Тогда
			Возврат ОписательОбъекта;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

Функция ЭтоОписательОбъектаСсылки(ОписательОбъекта, РезСсылка = Неопределено)
	ЭтоСсылочныйОбъект = ОписательОбъекта.Свойство("Ссылка", РезСсылка) И РезСсылка <> Неопределено;
	Возврат ЭтоСсылочныйОбъект;
КонецФункции

Функция ИмяПеременнойИзОписателяОбъекта(Мд, ОписательОбъекта)
	ИмяПеременной = "";
	Если НЕ ОписательОбъекта.Свойство("ИмяПеременной", ИмяПеременной) или ПустаяСтрока(ИмяПеременной) Тогда
		ИмяПеременной = Мд.Имя;
	КонецЕсли;
	Возврат ИмяПеременной;
КонецФункции

Функция ШапкаДанныхВМакете()
	рез = Новый Структура();
	рез.Вставить("Тип", 1);
	рез.Вставить("Вид", 2);
	рез.Вставить("ИмяПеременной", 3);
	рез.Вставить("ТЧ", 4);
	рез.Вставить("Реквизит", 5);
	рез.Вставить("Значение", 6);
	рез.Вставить("Режим", 7);
	Возврат рез;						
КонецФункции

// { БЛОК МЕТОДОВ ИЗ ИР (Инструменты Разработчика, автор TormozIt )
//
// Определяет корневой тип конфигурации по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные;
//  *пЛиТолькоДляКорневого - Булево, *Ложь - возвращать только для объекта корневого типа.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено - не удалось получить имя типа.
//
Функция ПолучитьКорневойТипКонфигурации_ирЛкс(пОбъект, пЛиТолькоДляКорневого = Ложь) Экспорт

	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеТипа = пОбъект;
	Иначе
		МетаданныеТипа = ПолучитьМетаданные_ирЛкс(пОбъект);
	КонецЕсли;
	Результат = Неопределено;
	Если МетаданныеТипа <> Неопределено Тогда
		ПолноеИмя = МетаданныеТипа.ПолноеИмя();
		Если пЛиТолькоДляКорневого Тогда 
			МассивФрагментов = ПолучитьМассивИзСтрокиСРазделителем_ирЛкс(ПолноеИмя);
			Если МассивФрагментов.Количество() = 2 Тогда
				Результат = МассивФрагментов[0];
			КонецЕсли;
		Иначе
			Результат = ПолучитьПервыйФрагмент_ирЛкс(ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	Если Результат = "ТабличнаяЧасть" Тогда
		// Баг платформы. У внешних метаданных полное имя не включает сам внешний метаобъект
		Результат = Неопределено;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции // ЛксПолучитьКорневойТипКонфигурации()

// Проверяет, является ли значение ссылкой на объект БД. На базе ЛксЛиСсылкаНаОбъектБД
//
// Параметры:
//  пЗначение    – ОбъектМетаданных, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является ссылкой на объект БД;
//  Ложь         – значение не является ссылкой на объект БД.
//
Функция ЛиСсылкаНаОбъектБД_ирЛкс(пЗначение) Экспорт

	Возврат ЛиКорневойТипОбъектаБД_ирЛкс(ПолучитьКорневойТипКонфигурации_ирЛкс(пЗначение, Истина));
		
КонецФункции // ЛксЛиСсылкаНаОбъектБД

// Проверяет, является ли значение ссылкой на значение перечисления.
//
// Параметры:
//  пЗначение    – Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Истина       – значение является ссылкой на объект БД;
//  Ложь         – значение не является ссылкой на объект БД.
//
Функция ЛиСсылкаНаПеречисление_ирЛкс(пЗначение) Экспорт

	Возврат (ПолучитьКорневойТипКонфигурации_ирЛкс(пЗначение) = "Перечисление");

КонецФункции // ЛксЛиСсылкаНаПеречисление()

// Проверяет, является ли строка именем корневого типа объекта БД.
//
// Параметры:
//  пИмяКорневогоТипа - Строка, Неопределено - имя корневого типа.
//
// Возвращаемое значение:
//  Истина       – тип является корневым типом объекта БД;
//  Ложь         – иначе.
//
Функция ЛиКорневойТипОбъектаБД_ирЛкс(КорневойТип) Экспорт

	Если Ложь
		ИЛИ КорневойТип = "БизнесПроцесс" 
		ИЛИ КорневойТип = "Задача" 
		ИЛИ КорневойТип = "Документ"
		ИЛИ КорневойТип = "ПланВидовРасчета" 
		ИЛИ КорневойТип = "ПланВидовХарактеристик" 
		ИЛИ КорневойТип = "ПланОбмена"
		ИЛИ КорневойТип = "ПланСчетов" 
		ИЛИ КорневойТип = "Справочник"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипОбъектаБД()

// Получает менеджер по описанию типов, типу, метаданным, ссылке или объекту. На базе метода ЛксПолучитьМенеджер
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем менеджер.
//
// Возвращаемое значение:
//               – МенеджерОбъекта - для ссылки или ссылочного типа;
//  Неопределено - не удалось получить.
//
Функция ПолучитьМенеджерОбъекта_ирЛкс(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеОбъекта = пОбъект;
	Иначе
		МетаданныеОбъекта = ПолучитьМетаданные_ирЛкс(пОбъект);
	КонецЕсли;
	Если МетаданныеОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	МассивФрагментов = ПолучитьМассивИзСтрокиСРазделителем_ирЛкс(МетаданныеОбъекта.ПолноеИмя());
	КорневойТип = МассивФрагментов[0];
	Менеджер = Неопределено;
	Если Истина
		И МассивФрагментов.Количество() = 4 
		И КорневойТип = "ВнешнийИсточникДанных" 
	Тогда
		ИмяТипаМенеджера = МассивФрагментов[0] + "ТаблицаМенеджер." + МассивФрагментов[1] + "." + МассивФрагментов[3];
	Иначе
		//КорневойТип = ЛксПолучитьКорневойТипКонфигурации(МетаданныеОбъекта, Истина); // Изменил 02.03.2012
		Если КорневойТип <> Неопределено Тогда
			ИмяТипаМенеджера = КорневойТип + "Менеджер." + МетаданныеОбъекта.Имя;
		Иначе
			ИмяТипаМенеджера = "Неопределено";
		КонецЕсли;
	КонецЕсли;
	Попытка
		Менеджер = Новый (ИмяТипаМенеджера);
	Исключение
	КонецПопытки;
	Возврат Менеджер;

КонецФункции // ЛксПолучитьМенеджер()

// Получает метаданные по полному имени, описанию типов, типу, ссылке или объекту. На базе ЛксПолучитьМетаданные
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные.
//
// Возвращаемое значение:
//               – Метаданные - полученные;
//  Неопределено - не удалось получить метаданные.
//
Функция ПолучитьМетаданные_ирЛкс(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("Строка") Тогда
		Если ПустаяСтрока(пОбъект) Тогда
			Результат = Неопределено;
		Иначе
			Фрагменты = ПолучитьМассивИзСтрокиСРазделителем_ирЛкс(пОбъект);
			Если Фрагменты.Количество() = 3 Тогда
				// ВидыСубконто, Изменения
				ПолноеИмяМД = Фрагменты[0] + "." + Фрагменты[1];
			Иначе
				ПолноеИмяМД = пОбъект;
			КонецЕсли; 
			Результат = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМД);
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	ТипОбъекта = ПолучитьТипОбъекта_ирЛкс(пОбъект);
	Результат = Метаданные.НайтиПоТипу(ТипОбъекта);
	Возврат Результат;
	
КонецФункции // ЛксПолучитьМетаданные()

// Получает тип из описания типов, типа или значения. На базе ЛксПолучитьТипОбъекта
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Тип - найденный тип.
//
Функция ПолучитьТипОбъекта_ирЛкс(пОбъект)

	ТипОбъекта = Тип("Неопределено");
	ТипПараметра = ТипЗнч(пОбъект);
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		Если пОбъект.Типы().Количество() > 0 Тогда 
			ТипОбъекта = пОбъект.Типы()[0];
		КонецЕсли;
	ИначеЕсли ТипПараметра <> Тип("Тип") Тогда 
		ТипОбъекта = ТипПараметра;
	Иначе
		ТипОбъекта = пОбъект;
	КонецЕсли;
	
	Возврат ТипОбъекта;

КонецФункции // ЛксПолучитьТипОбъекта()

// Функция разбивает строку разделителем. На базе ЛксПолучитьМассивИзСтрокиСРазделителем
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *ОбрезатьНепечатныеСимволы - Булево, *Ложь - делать СокрЛП.
//  *ОставлятьПустуюСтроку - Булево, *Истина - если передана пустая строка, то добавлять ее в массив.
//
// Возвращаемое значение:
//  Массив - фрагментов.
//
Функция ПолучитьМассивИзСтрокиСРазделителем_ирЛкс(Знач Стр, Разделитель = ".", ОбрезатьНепечатныеСимволы = Ложь, ОставлятьПустуюСтроку = Истина) Экспорт
	
	МассивСтрок = Новый Массив;
	Если Истина
		И Не ОставлятьПустуюСтроку 
		И ПустаяСтрока(Стр)
	Тогда
		Возврат МассивСтрок;
	КонецЕсли; 
	
	//лСтрока = СтрЗаменить(Стр, Разделитель, Символы.ПС);
	//// Баг платформы. СтрЧислоСтрок не учитывает терминальный перевод строки.
	//ЧислоСтрок = СтрЧислоСтрок(лСтрока + " ");
	//Для Счетчик = 1 По ЧислоСтрок Цикл 
	//	Фрагмент = СтрПолучитьСтроку(лСтрока, Счетчик);
	//	Если ОбрезатьНепечатныеСимволы Тогда
	//		Фрагмент = СокрЛП(Фрагмент);
	//	КонецЕсли;
	//	МассивСтрок.Добавить(Фрагмент);
	//КонецЦикла;
	
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				Фрагмент = Стр;
				Если ОбрезатьНепечатныеСимволы Тогда
					Фрагмент = СокрЛП(Фрагмент);
				КонецЕсли;
				МассивСтрок.Добавить(Фрагмент);
				Возврат МассивСтрок;
			КонецЕсли;
			Фрагмент = Лев(Стр,Поз-1);
			Если ОбрезатьНепечатныеСимволы Тогда
				Фрагмент = СокрЛП(Фрагмент);
			КонецЕсли;
			МассивСтрок.Добавить(Фрагмент);
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;

	Возврат МассивСтрок;
		
КонецФункции // ЛксПолучитьМассивИзСтрокиСРазделителем()

// Получает первый фрагмент, отделяемый разделителем от строки. На базе ЛксПолучитьПервыйФрагмент
// Написана для оптимизации по скорости.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *пЛиИспользоватьГраницуЕслиМаркерНеНайден - Булево, *Истина.
//
// Возвращаемое значение:
//               - Строка - первый фрагмент строки;
//  Неопределено - в строке не обнаружен разделитель.
//
Функция ПолучитьПервыйФрагмент_ирЛкс(пСтрока, пРазделитель = ".",
	пЛиИспользоватьГраницуЕслиМаркерНеНайден = Истина) Экспорт

	Позиция = Найти(пСтрока, пРазделитель);
	Если Позиция > 0 Тогда
		Возврат Лев(пСтрока, Позиция - 1);
	Иначе
		Если пЛиИспользоватьГраницуЕслиМаркерНеНайден Тогда 
			Возврат пСтрока;
		Иначе
			Возврат пСтрока;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ЛксПолучитьПервыйФрагмент()

// Получает идентификатор из любой строки.
// "3-я Дебиторка По контрагентам с интервалами СНГ (для  Руководства)" => "_3_яДебиторкаПоКонтрагентамСИнтерваламиСНГ_дляРуководства_".
//
// Параметры:
//  Представление – Строка.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИдентификаторИзПредставления_Лкс(Знач Представление, VBRegExp, ЗаменаПустойСтроки = "_") Экспорт
	Если VBRegExp = Неопределено Тогда
		VBRegExp = ПолучитьНовыйВычислительРегулярныхВыражений();
	КонецЕсли;
	
	шБуква = "_ЁА-ЯA-Z";

	Если ПустаяСтрока(Представление) Тогда
		Представление = ЗаменаПустойСтроки;
	КонецЕсли;
	Если СокрЛП(Представление) = Представление Тогда
		Попытка
			Пустышка = Новый Структура(Представление);
			Возврат Представление;
		Исключение КонецПопытки;
	КонецЕсли; 
	VBRegExp.Pattern = "\d";
	НовоеПредставление = Представление;
	ПервыйСимвол = Сред(Представление, 1, 1);
	Если VBRegExp.Test(ПервыйСимвол) Тогда
		// Первый символ - цифра
		НовоеПредставление = "_" + НовоеПредставление;
	КонецЕсли;
	ПредыдущийСимвол = " ";
	ТекущаяСтрока = "";
	Для Счетчик = 1 По СтрДлина(НовоеПредставление) Цикл
		ТекущийСимвол = Сред(НовоеПредставление, Счетчик, 1);
		VBRegExp.Pattern = "\s";
		Если VBRegExp.Test(ПредыдущийСимвол) Тогда
			// Предыдущий символ - непечатаемый
			ТекущийСимвол = ВРег(ТекущийСимвол);
		КонецЕсли;
		VBRegExp.Pattern = "[" + шБуква + "\d]";
		Если VBRegExp.Test(ТекущийСимвол) Тогда
			// Предыдущий символ - непечатаемый
			ТекущаяСтрока = ТекущаяСтрока + ТекущийСимвол;
		Иначе
			VBRegExp.Pattern = "[\S]";
			Если VBRegExp.Test(ТекущийСимвол) Тогда
				ТекущаяСтрока = ТекущаяСтрока + "_";
			КонецЕсли;
		КонецЕсли;
		ПредыдущийСимвол = ТекущийСимвол;
	КонецЦикла;
	Результат = ТекущаяСтрока;
	Возврат ТекущаяСтрока;

КонецФункции // ПолучитьИдентификаторИзПредставления()

Функция ПолучитьНовыйВычислительРегулярныхВыражений() Экспорт
	
	Результат = Новый COMОбъект("VBScript.RegExp");
	Результат.IgnoreCase = Истина;
	Возврат Результат;
	
КонецФункции
// } Конец блока методов из ИР (Инструменты Разработчика, автор TormozIt )

//} КОНЕЦ ОСНОВНОГО БЛОКА

//{ БЛОК ЮНИТ-ТЕСТОВ - сами тесты

Процедура ПередЗапускомТеста() Экспорт
	// в режиме транзакции какие-то проблемы с уникальностью кода :(
	// а вот без режима транзакций иногда не все созданные тестовые элементы Справочника.ПростойСправочник удаляются :(
	НачатьТранзакцию(); 
	
	ТестовыеДанныхДляУдаления = Новый Массив;
КонецПроцедуры

Процедура ПослеЗапускаТеста() Экспорт
	Если ТранзакцияАктивна() Тогда
		ОтменитьТранзакцию();
	КонецЕсли;	
	
	Для каждого ТестовыеДанные Из ТестовыеДанныхДляУдаления Цикл
		юТест.УдалитьСозданныеДанные(ТестовыеДанные);	
	КонецЦикла;
КонецПроцедуры

Процедура ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные)
	ТестовыеДанныхДляУдаления.Добавить(ТестовыеДанные);
КонецПроцедуры


Процедура ТестДолжен_ПолучитьМакетДляСозданияПростогоСправочника() Экспорт
	Макет = ПолучитьМакет("СозданиеПростогоСправочника");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование,РеквизитБулево", "Тестовое наименование", Истина);
	
	КоличествоДо = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, количествоДо, "количествоДо");
		
	ИмяПеременной = "ПростойСправочник1"; // ИмяПеременной - необязательный элемент
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);	
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник);
	описаниеЭлемента.Вставить("ИмяПеременной", ИмяПеременной);	
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
	
		юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременной), "Ожидали, что есть переменная '"+ИмяПеременной+"'");
		юТест.ПроверитьТип(ТестовыеДанные[ИмяПеременной], "СправочникСсылка.ПростойСправочник");
	
	КоличествоПосле = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, КоличествоПосле, "КоличествоПосле");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияОбъектаСЗаполненнымРеквизитомТипаПеречисление() Экспорт
	Макет = ПолучитьМакет("СозданиеОбъектаСЗаполненнымРеквизитомТипаПеречисление");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	ЗначениеПеречисления = Перечисления.Перечисление1.ЗначениеПеречисления1;
	Отбор = Новый Структура("Наименование,РеквизитПеречисление", "тЗначениеПеречисления1", ЗначениеПеречисления);
	
	КоличествоДо = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, количествоДо, "количествоДо");
		
	ИмяПеременной = "ПростойСправочник1"; // ИмяПеременной - необязательный элемент
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник);
	описаниеЭлемента.Вставить("ИмяПеременной", ИмяПеременной);	
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
	
		юТест.ПроверитьРавенство(ТестовыеДанные[ИмяПеременной].РеквизитПеречисление, ЗначениеПеречисления, "СправочникСсылка.ПростойСправочник.РеквизитПеречисление");
	
	КоличествоПосле = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор);
		юТест.ПроверитьРавенство(1, КоличествоПосле, "КоличествоПосле");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДвухПростыхСправочников() Экспорт
	Макет = ПолучитьМакет("СозданиеДвухПростыхСправочников");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, "ПростойСправочник1_1");
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник);
	описаниеЭлемента.Вставить("ИмяПеременной", "ПростойСправочник1_1");	
	описаниеЭлемента.Вставить("ВыгружатьКод", Ложь);

	ИмяПеременной2 = "ПростойСправочник2_1";
	//описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник2, ИмяПеременной2);
	описаниеЭлемента2 = СоздатьОписательЭлемента();
	описаниеЭлемента2.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник2);
	описаниеЭлемента2.Вставить("ИмяПеременной", ИмяПеременной2);	
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник2", Отбор), "количество2 после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(МассивДанных.Количество(), ТестовыеДанные.Количество(), "МассивДанных.Количество(), ТестовыеДанные.Количество() НовыйМакет");
		юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременной2), "Ожидали, что есть переменная '"+ИмяПеременной2+"'");
		юТест.ПроверитьТип(ТестовыеДанные[ИмяПеременной2], "СправочникСсылка.ПростойСправочник2");
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник2", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДвухСвязанныхСправочников() Экспорт
	Макет = ПолучитьМакет("СозданиеСвязанныхСправочников");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	ИмяПеременной = "ПростойСправочник1_1";
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник);
	описаниеЭлемента.Вставить("ИмяПеременной", ИмяПеременной);	
	описаниеЭлемента.Вставить("ВыгружатьКод", Ложь);
	описаниеЭлемента.Вставить("РежимПоиска", "Наименование");

	ИмяПеременной2 = "ИерархическийСправочник_1";
	//описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ИерархическийСправочник, ИмяПеременной2);
	описаниеЭлемента2 = СоздатьОписательЭлемента();
	описаниеЭлемента2.Вставить("Ссылка", ТестовыеДанные.ИерархическийСправочник);
	описаниеЭлемента2.Вставить("ИмяПеременной", ИмяПеременной2);	
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник", Отбор), "количество после удаления");
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор), "количество2 после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(МассивДанных.Количество(), ТестовыеДанные.Количество(), "МассивДанных.Количество(), ТестовыеДанные.Количество() НовыйМакет");
	юТест.ПроверитьРавенство(ТестовыеДанные[ИмяПеременной], ТестовыеДанные[ИмяПеременной2].ПростойСправочник);
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияСправочникаСРеквизитомСсылка_РежимПоискаКод() Экспорт
	Макет1 = ПолучитьМакет("СозданиеПростогоСправочника");
	ТестовыеДанные1 = юТест.СоздатьДанныеПоТабличномуДокументу(Макет1);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные1);
	
	Макет = ПолучитьМакет("СозданиеСправочникаСРеквизитомСсылка_РежимПоискаКод");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	ИмяПеременной2 = "ИерархическийСправочник_1";
	//описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ИерархическийСправочник, ИмяПеременной2);
	описаниеЭлемента2 = СоздатьОписательЭлемента();
	описаниеЭлемента2.Вставить("Ссылка", ТестовыеДанные.ИерархическийСправочник);
	описаниеЭлемента2.Вставить("ИмяПеременной", ИмяПеременной2);	
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор), "количество2 после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(МассивДанных.Количество(), ТестовыеДанные.Количество(), "МассивДанных.Количество(), ТестовыеДанные.Количество() НовыйМакет");
	юТест.ПроверитьРавенство(ТестовыеДанные[ИмяПеременной2].ПростойСправочник.Наименование, "Тестовое наименование");
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияСправочникаСДвумяСтрокамиВТабличнойЧасти() Экспорт
	Макет = ПолучитьМакет("СозданиеСправочникаСДвумяСтрокамиВТабличнойЧасти");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	НаименованиеПростогоЭлемента = "Тест";
	Отбор = Новый Структура("Наименование", "Тестовое наименование", Истина);
	
	ИмяПеременной2 = "СправочникСТабЧастью";
	//описаниеЭлемента2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.СправочникСТабЧастью, ИмяПеременной2);
	описаниеЭлемента2 = СоздатьОписательЭлемента();
	описаниеЭлемента2.Вставить("Ссылка", ТестовыеДанные.СправочникСТабЧастью);
	описаниеЭлемента2.Вставить("ИмяПеременной", ИмяПеременной2);	
	описаниеЭлемента2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента2);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	тестовыеДанные.СправочникСТабЧастью.ПолучитьОбъект().Удалить();
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("СправочникСТабЧастью", Отбор), "количество2 после удаления");
		
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);	
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
		юТест.ПроверитьРавенство(МассивДанных.Количество(), ТестовыеДанные.Количество(), "МассивДанных.Количество(), ТестовыеДанные.Количество() НовыйМакет");
		юТест.ПроверитьРавенство(2, ТестовыеДанные[ИмяПеременной2].Состав.Количество(), "ТестовыеДанные[ИмяПеременной].Состав.Количество()");
	тч = ТестовыеДанные[ИмяПеременной2].Состав;
	строка0 = тч[0];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента, строка0.ПростойСправочник.Наименование, "строка0.ПростойСправочник.Наименование");
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"1", строка0.ПростойСправочник2.Наименование, "строка0.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Истина, строка0.РеквизитБулево, "строка0.РеквизитБулево");
	строка1 = тч[1];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента, строка1.ПростойСправочник.Наименование, "строка1.ПростойСправочник.Наименование");
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"2", строка1.ПростойСправочник2.Наименование, "строка1.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Ложь, строка1.РеквизитБулево, "строка1.РеквизитБулево");
	
	Количество2После = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("СправочникСТабЧастью", Отбор);
		юТест.ПроверитьРавенство(Количество2После, 1, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДокументаСДвумяСтрокамиВТабличнойЧасти() Экспорт
	Макет = ПолучитьМакет("СозданиеДокументаСДвумяСтрокамиВТабличнойЧасти");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	НаименованиеПростогоЭлемента = "Тест";
	Отбор = Новый Структура; //("ПростойСправочник", ТестовыеДанные.ПростойСправочник);
	
	ИмяПеременной = "Документ2_2";
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.Документ, ИмяПеременной);
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.Документ);
	описаниеЭлемента.Вставить("ИмяПеременной", ИмяПеременной);	
	//описаниеЭлемента.Вставить("ВыгружатьКод", Ложь);
	
	//описаниеЭлемента_ПростойСправочник = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, "ПростойСправочник");
	описаниеЭлемента_ПростойСправочник = СоздатьОписательЭлемента();
	описаниеЭлемента_ПростойСправочник.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник);
	описаниеЭлемента_ПростойСправочник.Вставить("ИмяПеременной", "ПростойСправочник");	
	описаниеЭлемента_ПростойСправочник.Вставить("ВыгружатьКод", Ложь);
	
	//описаниеЭлемента_ПростойСправочник2 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник22, "ПростойСправочник22");
	описаниеЭлемента_ПростойСправочник2 = СоздатьОписательЭлемента();
	описаниеЭлемента_ПростойСправочник2.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник22);
	описаниеЭлемента_ПростойСправочник2.Вставить("ИмяПеременной", "ПростойСправочник22");	
	описаниеЭлемента_ПростойСправочник2.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента_ПростойСправочник);
	МассивДанных.Добавить(описаниеЭлемента_ПростойСправочник2);
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	НачалоПериода = '20140401'; //НачалоДня(ТекущаяДата());
	ОкончаниеПериода = КонецДня(НачалоПериода); //ТекущаяДата());
	тестовыеДанные.Документ.ПолучитьОбъект().Удалить();
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоДокументовПоОтбору("Документ1", НачалоПериода, ОкончаниеПериода, Отбор), "количество2 после удаления");
		
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);	
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);

		юТест.ПроверитьРавенство(МассивДанных.Количество(), ТестовыеДанные.Количество(), "МассивДанных.Количество(), ТестовыеДанные.Количество() НовыйМакет");
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента, ТестовыеДанные[ИмяПеременной].ПростойСправочник.Наименование, "ТестовыеДанные[ИмяПеременной].ПростойСправочник.Наименование");
		юТест.ПроверитьРавенство(2, ТестовыеДанные[ИмяПеременной].Состав.Количество(), "ТестовыеДанные[ИмяПеременной].Состав.Количество()");
	тч = ТестовыеДанные[ИмяПеременной].Состав;
	строка0 = тч[0];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"1", строка0.ПростойСправочник2.Наименование, "строка0.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Ложь, строка0.РеквизитБулево, "строка0.РеквизитБулево");
		юТест.ПроверитьРавенство(150, строка0.РеквизитЧисло, "строка0.РеквизитБулево");
	строка1 = тч[1];
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента+"2", строка1.ПростойСправочник2.Наименование, "строка1.ПростойСправочник2.Наименование");
		юТест.ПроверитьРавенство(Истина, строка1.РеквизитБулево, "строка1.РеквизитБулево");
		юТест.ПроверитьРавенство(0, строка1.РеквизитЧисло, "строка1.РеквизитБулево");
	
	Количество2После = юТест.ПолучитьКоличествоДокументовПоОтбору("Документ1", НачалоПериода, ОкончаниеПериода, Отбор);
		юТест.ПроверитьРавенство(1, Количество2После, "Количество2После");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияДвухЗаписейВРегистреСведений() Экспорт
	Макет = ПолучитьМакет("СозданиеДвухЗаписейВРегистреСведений");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	НаименованиеПростогоЭлемента = "Тест";
	Отбор = Новый Структура; //("ПростойСправочник", ТестовыеДанные.ПростойСправочник);
	
	Метаданное = "РегистрСведений";
	ВидМетаданного = "РегистрСведений1";
	МетаданныеРС = РегистрыСведений.РегистрСведений1.СоздатьНаборЗаписей().Метаданные();
	
	ИмяПеременнойЗаписиРС_1 = "ЗаписьРегистра1_1";
	РеквизитыЗаписи1 = Новый Структура("ПростойСправочник,ПростойСправочник2,РесурсЧисло,РесурсБулево");
	ЗаполнитьЗначенияСвойств(РеквизитыЗаписи1, ТестовыеДанные.ЗаписьРегистра1);
	//описаниеЗаписиРегистраСведений1 = Новый Структура("Метаданное,ИмяПеременной,Реквизиты", МетаданныеРС, ИмяПеременнойЗаписиРС_1, РеквизитыЗаписи1);
	описаниеЗаписиРегистраСведений1 = СоздатьОписательЭлемента();
	описаниеЗаписиРегистраСведений1.Вставить("Метаданное", МетаданныеРС);
	описаниеЗаписиРегистраСведений1.Вставить("ИмяПеременной", ИмяПеременнойЗаписиРС_1);	
	описаниеЗаписиРегистраСведений1.Вставить("Реквизиты", РеквизитыЗаписи1);	
	
	ИмяПеременнойЗаписиРС_2 = "ЗаписьРегистра1_2";
	РеквизитыЗаписи2 = Новый Структура("ПростойСправочник,ПростойСправочник2,РесурсЧисло,РесурсБулево");
	ЗаполнитьЗначенияСвойств(РеквизитыЗаписи2, ТестовыеДанные.ЗаписьРегистра2);
	//описаниеЗаписиРегистраСведений2 = Новый Структура("Метаданное,ИмяПеременной,Реквизиты", МетаданныеРС, ИмяПеременнойЗаписиРС_2, РеквизитыЗаписи2);
	описаниеЗаписиРегистраСведений2 = СоздатьОписательЭлемента();
	описаниеЗаписиРегистраСведений2.Вставить("Метаданное", МетаданныеРС);
	описаниеЗаписиРегистраСведений2.Вставить("ИмяПеременной", ИмяПеременнойЗаписиРС_2);	
	описаниеЗаписиРегистраСведений2.Вставить("Реквизиты", РеквизитыЗаписи2);	
	
	//описаниеЭлемента_ПростойСправочник = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, "ПростойСправочник");
	описаниеЭлемента_ПростойСправочник = СоздатьОписательЭлемента();
	описаниеЭлемента_ПростойСправочник.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник);
	описаниеЭлемента_ПростойСправочник.Вставить("ИмяПеременной", "ПростойСправочник");	
	описаниеЭлемента_ПростойСправочник.Вставить("ВыгружатьКод", Ложь);
	
	//описаниеЭлемента_ПростойСправочник22 = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник22, "ПростойСправочник22");
	описаниеЭлемента_ПростойСправочник22 = СоздатьОписательЭлемента();
	описаниеЭлемента_ПростойСправочник22.Вставить("Ссылка", ТестовыеДанные.ПростойСправочник22);
	описаниеЭлемента_ПростойСправочник22.Вставить("ИмяПеременной", "ПростойСправочник22");	
	описаниеЭлемента_ПростойСправочник22.Вставить("ВыгружатьКод", Ложь);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента_ПростойСправочник);
	МассивДанных.Добавить(описаниеЭлемента_ПростойСправочник22);
	МассивДанных.Добавить(описаниеЗаписиРегистраСведений1);
	МассивДанных.Добавить(описаниеЗаписиРегистраСведений2);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	//НовыйМакет.Показать();
	
	наборЗаписей = РегистрыСведений.РегистрСведений1.СоздатьНаборЗаписей();
	наборЗаписей.Записать();
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовРегистраПоОтбору(Метаданное, ВидМетаданного, Отбор), "количество2 после удаления");
		
	ПростойСправочник21_ИмяПеременной = "ПростойСправочник21";
	ПростойСправочник21 = ТестовыеДанные[ПростойСправочник21_ИмяПеременной];
	Отбор_ПростойСправочник21 = Новый Структура("Ссылка", ПростойСправочник21);
	Отбор_ПростойСправочник21_Наименование = Новый Структура("Наименование", ПростойСправочник21.Наименование);
		юТест.ПроверитьРавенство(НаименованиеПростогоЭлемента + "1", ПростойСправочник21.Наименование);
	
	//ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);	
	тестовыеДанные.Удалить(ПростойСправочник21_ИмяПеременной);
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
	
		юТест.ПроверитьРавенство(1, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник2", Отбор_ПростойСправочник21), "количество Отбор_ПростойСправочник21 после удаления");
		юТест.ПроверитьРавенство(1, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПростойСправочник2", Отбор_ПростойСправочник21_Наименование), "количество Отбор_ПростойСправочник21_Наименование после удаления");

	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);

		юТест.ПроверитьРавенство(2, юТест.ПолучитьКоличествоЭлементовРегистраПоОтбору(Метаданное, ВидМетаданного, Отбор), "количество после добавления");
	
		юТест.ПроверитьРавенство(МассивДанных.Количество(), ТестовыеДанные.Количество(), "МассивДанных.Количество(), ТестовыеДанные.Количество() НовыйМакет");
	юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременнойЗаписиРС_1), "Ожидали, что есть переменная '"+ИмяПеременнойЗаписиРС_1+"'");
	менеджерЗаписи1 = ТестовыеДанные[ИмяПеременнойЗаписиРС_1];
	юТест.ПроверитьРавенство(ТестовыеДанные.ПростойСправочник, менеджерЗаписи1.ПростойСправочник);
	юТест.ПроверитьРавенство(ПростойСправочник21, менеджерЗаписи1.ПростойСправочник2);
	юТест.ПроверитьРавенство(300, менеджерЗаписи1.РесурсЧисло);
	юТест.ПроверитьЛожь(менеджерЗаписи1.РесурсБулево);
	
	юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременнойЗаписиРС_2), "Ожидали, что есть переменная '"+ИмяПеременнойЗаписиРС_2+"'");
	менеджерЗаписи2 = ТестовыеДанные[ИмяПеременнойЗаписиРС_2];
	юТест.ПроверитьРавенство(ТестовыеДанные.ПростойСправочник, менеджерЗаписи2.ПростойСправочник);
	юТест.ПроверитьРавенство(ТестовыеДанные.ПростойСправочник22, менеджерЗаписи2.ПростойСправочник2);
	юТест.ПроверитьРавенство(400, менеджерЗаписи2.РесурсЧисло);
	юТест.ПроверитьИстину(менеджерЗаписи2.РесурсБулево);
		
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияПодчиненногоСправочника() Экспорт
	Макет = ПолучитьМакет("СозданиеПодчиненногоСправочника");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование,Владелец", "Подчиненный элемент", Справочники.ПростойСправочник.ПредопределенноеЗначение1);
	
	КоличествоДо = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПодчиненныйСправочник", Отбор);
		юТест.ПроверитьРавенство(1, количествоДо, "количествоДо");
		
	ИмяПеременной = "ПодчиненныйЭлемент1"; // ИмяПеременной - необязательный элемент
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);	
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.ПодчиненныйЭлемент);
	описаниеЭлемента.Вставить("ИмяПеременной", ИмяПеременной);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПодчиненныйСправочник", Отбор), "количество после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
	
		юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременной), "Ожидали, что есть переменная '"+ИмяПеременной+"'");
		юТест.ПроверитьТип(ТестовыеДанные[ИмяПеременной], "СправочникСсылка.ПодчиненныйСправочник");
	
	КоличествоПосле = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ПодчиненныйСправочник", Отбор);
		юТест.ПроверитьРавенство(1, КоличествоПосле, "КоличествоПосле");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСозданияИерархическогоСправочника() Экспорт
	Макет = ПолучитьМакет("СозданиеСправочникаВГруппе");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
		
	Отбор = Новый Структура("Наименование,Родитель", "Элемент в группе", Справочники.ИерархическийСправочник.Группа1);
	
	КоличествоДо = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор);
		юТест.ПроверитьРавенство(1, количествоДо, "количествоДо");
		
	ИмяПеременной = "ЭлементВГруппе1"; // ИмяПеременной - необязательный элемент
	//описаниеЭлемента = Новый Структура("Ссылка,ИмяПеременной", ТестовыеДанные.ПростойСправочник, ИмяПеременной);	
	описаниеЭлемента = СоздатьОписательЭлемента();
	описаниеЭлемента.Вставить("Ссылка", ТестовыеДанные.ЭлементВГруппе);
	описаниеЭлемента.Вставить("ИмяПеременной", ИмяПеременной);
	
	МассивДанных = Новый Массив;
	МассивДанных.Добавить(описаниеЭлемента);
		
	НовыйМакет = ЭтотОбъект.СоздатьМакетДляГенерацииДанных(массивДанных);
	
	юТест.УдалитьСозданныеДанные(тестовыеДанные);
		юТест.ПроверитьРавенство(0, юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор), "количество после удаления");
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(НовыйМакет);
	ДобавитьТестовыеДанныхДляУдаления(ТестовыеДанные);
	
		юТест.ПроверитьИстину(ТестовыеДанные.Свойство(ИмяПеременной), "Ожидали, что есть переменная '"+ИмяПеременной+"'");
		юТест.ПроверитьТип(ТестовыеДанные[ИмяПеременной], "СправочникСсылка.ИерархическийСправочник");
	
	КоличествоПосле = юТест.ПолучитьКоличествоЭлементовСправочникаПоОтбору("ИерархическийСправочник", Отбор);
		юТест.ПроверитьРавенство(1, КоличествоПосле, "КоличествоПосле");
КонецПроцедуры

Процедура ТестДолжен_ПолучитьМакетДляСоздания2ЗаписейРегистраСведений() Экспорт
	Макет = ПолучитьМакет("СозданиеДвухЗаписейВРегистреСведений");
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(Макет);
	
	НаименованиеПростогоЭлемента = "Тест";
	Отбор = Новый Структура; //("ПростойСправочник", ТестовыеДанные.ПростойСправочник);
	//
	Метаданное = "РегистрСведений";
	ВидМетаданного = "РегистрСведений1";
	
	юТест.ПроверитьРавенство(2, юТест.ПолучитьКоличествоЭлементовРегистраПоОтбору(Метаданное, ВидМетаданного, Отбор), "количество после добавления");
		
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	""РегистрыСведений.РегистрСведений1.СоздатьНаборЗаписей().Метаданные()"" КАК __Метаданные,
		|	""ЗаписьРегистра"" КАК __Префикс,
		|
		|	РегистрСведений1.ПростойСправочник,
		|	РегистрСведений1.ПростойСправочник2,
		|	РегистрСведений1.РесурсЧисло,
		|	РегистрСведений1.РесурсБулево
		|ИЗ
		|	РегистрСведений.РегистрСведений1 КАК РегистрСведений1";

	РезультатЗапроса = Запрос.Выполнить();
	МакетРез = ЭтотОбъект.СоздатьМакетДанныхНаОснованииЗапроса(РезультатЗапроса);	
	
	МакетИсх = ПолучитьМакет("ЭталонМакетаДвухЗаписейВРегистреСведений");
	ФайлИсх = ПолучитьИмяВременногоФайла("txt");
	МакетИсх.Записать(ФайлИсх, ТипФайлаТабличногоДокумента.ANSITXT); // сохраняю в текст для отключения сравнения форматирования
	ФайлРез = ПолучитьИмяВременногоФайла("txt");
	МакетРез.Записать(ФайлРез, ТипФайлаТабличногоДокумента.ANSITXT);
	
	ЮТест.ПроверитьРавенствоФайлов(ФайлИсх, ФайлРез, "ФайлИсх, ФайлРез", Неопределено, Истина);
КонецПроцедуры

//} КОНЕЦ БЛОКА ЮНИТ-ТЕСТОВ


Процедура ПриИзмененииСсылки(ИдентификаторСтрокиДанных) Экспорт
	ЭлементДанных = ИдентификаторСтрокиДанных;
	Если ЗначениеЗаполнено(ЭлементДанных.Ссылка) Тогда
		Ид = ПолучитьИдентификаторПредставленияПоСсылке(ЭлементДанных.Ссылка);
		ЭлементДанных.ИмяПеременной = Ид;
		ЭлементДанных.Метаданное = ЭлементДанных.Ссылка.Метаданные().ПолноеИмя();
		ЭлементДанных.РежимПоиска = "Перем";
	КонецЕсли;
КонецПроцедуры

Функция СоздатьМакетДанных(Макет) Экспорт
	Макет.Очистить();
	массивДанных = Новый Массив;
	Для каждого строка Из ТаблицаДанных Цикл
		ОписательЭлемента = СоздатьОписательЭлемента();
		ЗаполнитьЗначенияСвойств(ОписательЭлемента, строка);
		массивДанных.Добавить(ОписательЭлемента);
	КонецЦикла;
	НовыйМакет = СоздатьМакетДляГенерацииДанных(массивДанных);
	Если ТипЗнч(НовыйМакет) = Тип("ТабличныйДокумент") Тогда
		Макет.Вывести(НовыйМакет);
	КонецЕсли;
	Возврат НовыйМакет;
КонецФункции

Функция ПолучитьКаталогОбработки() Экспорт
	Файл = Новый Файл(ИспользуемоеИмяФайла);
	Возврат Файл.Путь;
КонецФункции

Процедура ПроверитьЗагрузкуМакета(ИдОбработки_юТест, ТабличныйДокумент, ЕстьВстроеннаяОбработка_юТест = Ложь) Экспорт
	НачатьТранзакцию();
	
	Если ЕстьВстроеннаяОбработка_юТест Тогда
		юТест = Обработки.UnitTestRunner.Создать();
	Иначе
		юТест = ВнешниеОбработки.Создать(ИдОбработки_юТест);
	КонецЕсли;
	
	ТестовыеДанные = юТест.СоздатьДанныеПоТабличномуДокументу(ТабличныйДокумент);
		юТест.ПроверитьНеРавенство(0, ТестовыеДанные.Количество(), "не заполнены тестовые данные. Возможно, макет данных пуст!" );
		
	Если ТранзакцияАктивна() Тогда
		ОтменитьТранзакцию();
	КонецЕсли;
	Сообщить("Проверка загрузки объектов в ИБ из макета данных выполнена успешно.");
КонецПроцедуры

Функция ПодключитьВнешнююОбработку(АдресХранилища, ИдентификаторОбработки, ПолныйПутьФайлаОбработки) Экспорт
	#Если Клиент Тогда
	Возврат ПолныйПутьФайлаОбработки;
	#Иначе
	Возврат ВнешниеОбработки.Подключить(АдресХранилища, ИдентификаторОбработки, Ложь); // подключаю не в безопасном режиме
	#КонецЕсли
КонецФункции

ЕстьВстроеннаяОбработка_юТест = Не Метаданные.Обработки.Найти("UnitTestRunner") = Неопределено;
// тест
